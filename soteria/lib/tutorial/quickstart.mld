{1 Soteria Quick Start}

Welcome to the Soteria tutorial! This tutorial will guide you through the basics of writing a symbolic execution engine.

Today you'll be learning how to:
- {{!instantiate}Instantiate} the {{!Soteria_symex.Symex.Make_iter}Symex} functor
- {!return}
- {!nondet}
- {!bind}
- {!branching}
- {!interp}

{2:instantiate Instantiating the Symex functor}

The main utility of the Soteria library is the {!Symex} functor, which provides the necessary infrastructure to define and run a symbolic execution engine.
To instantiate it, you need to provide a {{!Soteria_symex.Solver.Mutable_incremental} Solver} module, which defines {e symbolic values} and the solver interface to decide whether a symbolic expression of type {{!Soteria_symex.Value.S.sbool}Value.sbool} is satisfiable.

{@ocaml[
module Symex = Symex.Make_iter (C_solver.Z3_solver)
]}

Here, we use {{!Soteria_symex.Symex.Make_iter} Make_iter} to create a symbolic execution monad where the base monad is {!iter/module-Iter}. The alternative is {{!Soteria_symex.Symex.Make_seq}Make_seq}, which uses {!Stdlib.Seq.t} as the base monad. Soteria offers both monads, though we have not found significant differences in performance.

{2:return Write your first symbolic process}

Soteria is a library to write {e symbolic processes}. A symbolic process is a value of the type {{!Soteria_symex.  Symex.S.t}Symex.t}, which is effectively a symbolic computation waiting to be executed. It is an execution that may depend on {e symbolic variables}, and therefore may branch into multiple paths depending on the values of these variables.

The simplest such process is the symbolic process just returns a single branch with a given value, say the integer [0].

{@ocaml[
# Symex.return 0;;
- : int Symex.t = <abstr>
]}


This process has type [int Symex.t], that is, a symbolic process that returns a value of type [int]. Again, this is a symbolic process, so it is {e not yet executed}.
Executing a symbolic process is done using the {{!Soteria_symex.Symex.S.run}run} function:
{@ocaml[
# Symex.run
- : fuel:Fuel_gauge.t ->
    'a Symex.t -> ('a * Symex.Value.sbool Typed.t list) list
= <fun>
]}

The function receives a fuel gauge used to limit the number of steps and branches in the symbolic execution (avoiding e.g. infinite loops), and a symbolic process to execute. It returns a list of branches, where each branch is a pair of the value returned by the symbolic process and the path condition that leads to this branch (in the form of a list of symbolic booleans).

For instance, let's execute the symbolic process we just created, providing an infinite fuel gauge (which means that the symbolic execution will not be limited by the number of steps or branches, which is irrelevant here anyway).

{@ocaml[
# Symex.return 0 |> Symex.run ~fuel:Fuel_gauge.infinite;;
- : (int * Symex.Value.sbool Typed.t list) list = [(0, [true])]
]}

As expected the result of the symbolic process is a single branch with the value [0] and an empty path condition [[]], which means that there is no condition for taking this branch, i.e., it is always taken.

{2:nondet Introducing fresh symbolic values}

A core necessity of symbolic execution is the ability to introduce fresh symbolic values. Soteria provides a convenient way to do this using the {{!Soteria_symex.Symex.S.nondet}nondet} function, which creates a fresh symbolic value of a given type. It is called {e nondet} because it "abstracts over" a nondeterministic choice of any value of that given type:

{@ocaml[
# Symex.nondet;;
- : 'a Typed.ty -> 'a Typed.t Symex.t = <fun>
]}

{{!Soteria_symex.Symex.S.nondet}[nondet]} receives a type [ty] and returns a symbolic process that produces a fresh symbolic value of that type. It can also take an optional argument

{2:bind Compose symbolic processes together}

{2:branching Introduce branching in symbolic processes}

A more interesting symbolic process is one that introduces conditional branching. For instance, we can introduce a process that introduces a fresh nondeterministic integer, and then branches on whether this integer is even or odd. Soteria provides convenient syntactic, which can be accessed by opening the {{!Soteria_symex.Symex.S.Syntax}Symex.Syntax} module.

{@ocaml[
(* Syntax for symbolic execution: let* and if%sat *)
open Symex.Syntax

(* Infix operators for symbolic values *)
open Typed.Infix

(* Allows writing e.g. 2s for the symbolic integer 2 *)
open Typed.Syntax

let process =
    let* x = Symex.nondet Typed.t_int in
    if%sat (x %@ 2s) ==@ 0s then
      Symex.return (Fmt.str "%a is even" Typed.ppa x)
    else
      Symex.return (Fmt.str "%a is odd" Typed.ppa x)
]}

Here, [process] is the symbolic process itself, and is yet to be executed. To execute it, we can use the same {{!Soteria_symex.Symex.S.run}run} function as before.

{@ocaml[
# Symex.run ~fuel:Fuel_gauge.infinite process;;
- : (string * Symex.Value.sbool Typed.t list) list =
[("V|1| is even", [true; (0 == (V|1| mod 2))]);
 ("V|1| is odd", [true; (0 != (V|1| mod 2))])]
]}

As expected, the symbolic process returns two branches, one for the case where the symbolic integer is even, and one for the case where it is odd. In each case, the path condition is a symbolic expression that describes the corresponding condition on the symbolic variable created (called [V|1|] here).

{2:interp Write a small symbolic interpreter}