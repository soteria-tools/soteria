<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>M (soteria-rust.Soteria_rust_lib.Builtins.Intrinsics.M)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../../index.html">Index</a> &#x00BB; <a href="../../../../index.html">soteria-rust</a> &#x00BB; <a href="../../../index.html">Soteria_rust_lib</a> &#x00BB; <a href="../../index.html">Builtins</a> &#x00BB; <a href="../index.html">Intrinsics</a> &#x00BB; M</nav><header class="odoc-preamble"><h1>Module <code><span>Intrinsics.M</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav></div><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-State"><a href="#argument-1-State" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-State/index.html">State</a></span><span> : <a href="../../../State_intf/module-type-S/index.html">State_intf.S</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="odoc-spec"><div class="spec type subst anchored" id="type-rust_val"><a href="#type-rust_val" class="anchor"></a><code><span><span class="keyword">type</span> rust_val</span><span> := <span><a href="argument-1-State/Sptr/index.html#type-t">State.Sptr.t</a> <a href="../../../Rust_val/index.html#type-t">Rust_val.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-ret"><a href="#type-ret" class="anchor"></a><code><span><span class="keyword">type</span> ret</span><span> :=
  <span><span>(<a href="#type-rust_val">rust_val</a> * <a href="argument-1-State/index.html#type-t">State.t</a>, <span><a href="../../../Error/index.html#type-t">Error.t</a> <a href="argument-1-State/index.html#type-err">State.err</a></span> * <a href="argument-1-State/index.html#type-t">State.t</a>, <span><a href="argument-1-State/index.html#type-serialized">State.serialized</a> list</span>)</span>
    <a href="../../../Rustsymex/SYMEX/Result/index.html#type-t">Soteria_rust_lib.Rustsymex.Result.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-fun_exec"><a href="#type-fun_exec" class="anchor"></a><code><span><span class="keyword">type</span> fun_exec</span><span> :=
  <span><span class="xref-unresolved">Charon</span>.UllbcAst.fun_decl <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">args</span>:<span><a href="#type-rust_val">rust_val</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-rust_val">rust_val</a> * <a href="argument-1-State/index.html#type-t">State.t</a>, <span><a href="../../../Error/index.html#type-t">Error.t</a> <a href="argument-1-State/index.html#type-err">State.err</a></span> * <a href="argument-1-State/index.html#type-t">State.t</a>, <span><a href="argument-1-State/index.html#type-serialized">State.serialized</a> list</span>)</span>
    <a href="../../../Rustsymex/SYMEX/Result/index.html#type-t">Soteria_rust_lib.Rustsymex.Result.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-abort"><a href="#val-abort" class="anchor"></a><code><span><span class="keyword">val</span> abort : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Aborts the execution of the process.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p><code>std::process::abort</code>(../../std/process/fn.abort.html) is to be preferred if possible, as its behavior is more user-friendly and more stable.</p><p>The current implementation of <code>intrinsics::abort</code> is to invoke an invalid instruction, on most platforms. On Unix, the process will probably terminate with a signal like <code>SIGABRT</code>, <code>SIGILL</code>, <code>SIGTRAP</code>, <code>SIGSEGV</code> or <code>SIGBUS</code>. The precise behavior is not guaranteed and not stable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_with_overflow"><a href="#val-add_with_overflow" class="anchor"></a><code><span><span class="keyword">val</span> add_with_overflow : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs checked integer addition.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>overflowing_add</code> method. For example, <code>u32::overflowing_add</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-aggregate_raw_ptr"><a href="#val-aggregate_raw_ptr" class="anchor"></a><code><span><span class="keyword">val</span> aggregate_raw_ptr : 
  <span><span class="label">p</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">d</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">m</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">meta</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Lowers in MIR to <code>Rvalue::Aggregate</code> with <code>AggregateKind::RawPtr</code>.</p><p>This is used to implement functions like <code>slice::from_raw_parts_mut</code> and <code>ptr::from_raw_parts</code> in a way compatible with the compiler being able to change the possible layouts of pointers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-align_of"><a href="#val-align_of" class="anchor"></a><code><span><span class="keyword">val</span> align_of : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The minimum alignment of a type.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>align_of</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-align_of_val"><a href="#val-align_of_val" class="anchor"></a><code><span><span class="keyword">val</span> align_of_val : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The required alignment of the referenced value.</p><p>The stabilized version of this intrinsic is <code>align_of_val</code>.</p><p># Safety</p><p>See <code>crate::mem::align_of_val_raw</code> for safety conditions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-arith_offset"><a href="#val-arith_offset" class="anchor"></a><code><span><span class="keyword">val</span> arith_offset : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">offset</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Calculates the offset from a pointer, potentially wrapping.</p><p>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.</p><p># Safety</p><p>Unlike the <code>offset</code> intrinsic, this intrinsic does not restrict the resulting pointer to point into or at the end of an allocated object, and it wraps with two's complement arithmetic. The resulting value is not necessarily valid to be used to actually access memory.</p><p>The stabilized version of this intrinsic is <code>pointer::wrapping_offset</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assert_inhabited"><a href="#val-assert_inhabited" class="anchor"></a><code><span><span class="keyword">val</span> assert_inhabited : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>A guard for unsafe functions that cannot ever be executed if <code>T</code> is uninhabited: This will statically either panic, or do nothing. It does not *guarantee* to ever panic, and should only be called if an assertion failure will imply language UB in the following code.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assert_mem_uninitialized_valid"><a href="#val-assert_mem_uninitialized_valid" class="anchor"></a><code><span><span class="keyword">val</span> assert_mem_uninitialized_valid : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>A guard for <code>std::mem::uninitialized</code>. This will statically either panic, or do nothing. It does not *guarantee* to ever panic, and should only be called if an assertion failure will imply language UB in the following code.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assert_zero_valid"><a href="#val-assert_zero_valid" class="anchor"></a><code><span><span class="keyword">val</span> assert_zero_valid : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>A guard for unsafe functions that cannot ever be executed if <code>T</code> does not permit zero-initialization: This will statically either panic, or do nothing. It does not *guarantee* to ever panic, and should only be called if an assertion failure will imply language UB in the following code.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assume"><a href="#val-assume" class="anchor"></a><code><span><span class="keyword">val</span> assume : <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</p><p>No code is generated for this intrinsic, but the optimizer will try to preserve it (and its condition) between passes, which may interfere with optimization of surrounding code and reduce performance. It should not be used if the invariant can be discovered by the optimizer on its own, or if it does not enable any significant optimizations.</p><p>The stabilized version of this intrinsic is <code>core::hint::assert_unchecked</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bitreverse"><a href="#val-bitreverse" class="anchor"></a><code><span><span class="keyword">val</span> bitreverse : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Reverses the bits in an integer type <code>T</code>.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>reverse_bits</code> method. For example, <code>u32::reverse_bits</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-black_box"><a href="#val-black_box" class="anchor"></a><code><span><span class="keyword">val</span> black_box : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dummy</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>See documentation of <code>std::hint::black_box</code> for details.</p><p><code>std::hint::black_box</code>: crate::hint::black_box</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-breakpoint"><a href="#val-breakpoint" class="anchor"></a><code><span><span class="keyword">val</span> breakpoint : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Executes a breakpoint trap, for inspection by a debugger.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bswap"><a href="#val-bswap" class="anchor"></a><code><span><span class="keyword">val</span> bswap : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Reverses the bytes in an integer type <code>T</code>.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>swap_bytes</code> method. For example, <code>u32::swap_bytes</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-caller_location"><a href="#val-caller_location" class="anchor"></a><code><span><span class="keyword">val</span> caller_location : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Gets a reference to a static <code>Location</code> indicating where it was called.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>Consider using <code>core::panic::Location::caller</code> instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-carrying_mul_add"><a href="#val-carrying_mul_add" class="anchor"></a><code><span><span class="keyword">val</span> carrying_mul_add : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">u</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">multiplier</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">multiplicand</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">addend</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">carry</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs full-width multiplication and addition with a carry: <code>multiplier * multiplicand + addend + carry</code>.</p><p>This is possible without any overflow. For <code>uN</code>: MAX * MAX + MAX + MAX =&gt; (2ⁿ-1) × (2ⁿ-1) + (2ⁿ-1) + (2ⁿ-1) =&gt; (2²ⁿ - 2ⁿ⁺¹ + 1) + (2ⁿ⁺¹ - 2) =&gt; 2²ⁿ \- 1</p><p>For <code>iN</code>, the upper bound is MIN * MIN + MAX + MAX =&gt; 2²ⁿ⁻² + 2ⁿ - 2, and the lower bound is MAX * MIN + MIN + MIN =&gt; -2²ⁿ⁻² - 2ⁿ + 2ⁿ⁺¹.</p><p>This currently supports unsigned integers *only*, no signed ones. The stabilized versions of this intrinsic are available on integers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-catch_unwind"><a href="#val-catch_unwind" class="anchor"></a><code><span><span class="keyword">val</span> catch_unwind : 
  <span><a href="#type-fun_exec">fun_exec</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_try_fn</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_catch_fn</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Rust's &quot;try catch&quot; construct for unwinding. Invokes the function pointer <code>try_fn</code> with the data pointer <code>data</code>, and calls <code>catch_fn</code> if unwinding occurs while <code>try_fn</code> runs. Returns <code>1</code> if unwinding occurred and <code>catch_fn</code> was called; returns <code>0</code> otherwise.</p><p><code>catch_fn</code> must not unwind.</p><p>The third argument is a function called if an unwind occurs (both Rust <code>panic</code> and foreign unwinds). This function takes the data pointer and a pointer to the target- and runtime-specific exception object that was caught.</p><p>Note that in the case of a foreign unwinding operation, the exception object data may not be safely usable from Rust, and should not be directly exposed via the standard library. To prevent unsafe access, the library implementation may either abort the process or present an opaque error type to the user.</p><p>For more information, see the compiler's source, as well as the documentation for the stable version of this intrinsic, <code>std::panic::catch_unwind</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceilf128"><a href="#val-ceilf128" class="anchor"></a><code><span><span class="keyword">val</span> ceilf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the smallest integer greater than or equal to an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::ceil</code>(../../std/primitive.f128.html#method.ceil)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceilf16"><a href="#val-ceilf16" class="anchor"></a><code><span><span class="keyword">val</span> ceilf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the smallest integer greater than or equal to an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::ceil</code>(../../std/primitive.f16.html#method.ceil)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceilf32"><a href="#val-ceilf32" class="anchor"></a><code><span><span class="keyword">val</span> ceilf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the smallest integer greater than or equal to an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::ceil</code>(../../std/primitive.f32.html#method.ceil)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceilf64"><a href="#val-ceilf64" class="anchor"></a><code><span><span class="keyword">val</span> ceilf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the smallest integer greater than or equal to an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::ceil</code>(../../std/primitive.f64.html#method.ceil)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cold_path"><a href="#val-cold_path" class="anchor"></a><code><span><span class="keyword">val</span> cold_path : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Hints to the compiler that current code path is cold.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_bytes"><a href="#val-compare_bytes" class="anchor"></a><code><span><span class="keyword">val</span> compare_bytes : 
  <span><span class="label">left</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">right</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">bytes</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Lexicographically compare <code>[left, left + bytes)] and [[right, right + bytes)] as unsigned bytes, returning negative if [left] is less, zero if all the bytes match, or positive if [left] is greater. This underlies things like [&lt;[u8]&gt;::cmp], and will usually lower to [memcmp]. # Safety [left] and [right] must each be [valid] for reads of [bytes] bytes. Note that this applies to the whole range, not just until the first byte that differs.  That allows optimizations that can read in large chunks. [valid]: crate::ptr#safety </code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-const_deallocate"><a href="#val-const_deallocate" class="anchor"></a><code><span><span class="keyword">val</span> const_deallocate : 
  <span><span class="label">_ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_size</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_align</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Deallocates a memory which allocated by <code>intrinsics::const_allocate</code> at compile time. At runtime, does nothing.</p><p># Safety</p><ul><li>The <code>align</code> argument must be a power of two.</li><li>At compile time, a compile error occurs if this constraint is violated.</li><li>At runtime, it is not checked.</li><li>If the <code>ptr</code> is created in an another const, this intrinsic doesn't deallocate it.</li><li>If the <code>ptr</code> is pointing to a local variable, this intrinsic doesn't deallocate it.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-const_eval_select"><a href="#val-const_eval_select" class="anchor"></a><code><span><span class="keyword">val</span> const_eval_select : 
  <span><span class="label">arg</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">f</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">g</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ret</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_arg</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_called_in_const</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_called_at_rt</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Selects which function to call depending on the context.</p><p>If this function is evaluated at compile-time, then a call to this intrinsic will be replaced with a call to <code>called_in_const</code>. It gets replaced with a call to <code>called_at_rt</code> otherwise.</p><p>This function is safe to call, but note the stability concerns below.</p><p># Type Requirements</p><p>The two functions must be both function items. They cannot be function pointers or closures. The first function must be a <code>const fn</code>.</p><p><code>arg</code> will be the tupled arguments that will be passed to either one of the two functions, therefore, both functions must accept the same type of arguments. Both functions must return RET.</p><p># Stability concerns</p><p>Rust has not yet decided that <code>const fn</code> are allowed to tell whether they run at compile-time or at runtime. Therefore, when using this intrinsic anywhere that can be reached from stable, it is crucial that the end-to-end behavior of the stable <code>const fn</code> is the same for both modes of execution. (Here, Undefined Behavior is considered &quot;the same&quot; as any other behavior, so if the function exhibits UB at runtime then it may do whatever it wants at compile-time.)</p><p>Here is an example of how this could cause a problem: `no_run #!<code>feature(const_eval_select)</code> #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code> use std::intrinsics::const_eval_select;</p><p>// Standard library pub const fn inconsistent() -&gt; i32 <code>
fn runtime() -&gt; i32 { 1 </code> const fn compiletime() -&gt; i32 <code> 2 </code></p><p>// ⚠ This code violates the required equivalence of <code>compiletime</code> // and <code>runtime</code>. const_eval_select((), compiletime, runtime)</p><p>}</p><p>// User Crate const X: i32 = inconsistent(); let x = inconsistent(); assert_eq!(x, X); `</p><p>Currently such an assertion would always succeed; until Rust decides otherwise, that principle should not be violated.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contract_check_ensures"><a href="#val-contract_check_ensures" class="anchor"></a><code><span><span class="keyword">val</span> contract_check_ensures : 
  <span><span class="label">c</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">t_ret</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cond</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ret</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Check if the post-condition <code>cond</code> has been met.</p><p>By default, if <code>contract_checks</code> is enabled, this will panic with no unwind if the condition returns false.</p><p>Note that this function is a no-op during constant evaluation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contract_check_requires"><a href="#val-contract_check_requires" class="anchor"></a><code><span><span class="keyword">val</span> contract_check_requires : 
  <span><span class="label">c</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">arg1</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Check if the pre-condition <code>cond</code> has been met.</p><p>By default, if <code>contract_checks</code> is enabled, this will panic with no unwind if the condition returns false.</p><p>Note that this function is a no-op during constant evaluation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contract_checks"><a href="#val-contract_checks" class="anchor"></a><code><span><span class="keyword">val</span> contract_checks : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns whether we should perform contract-checking at runtime.</p><p>This is meant to be similar to the ub_checks intrinsic, in terms of not prematurely committing at compile-time to whether contract checking is turned on, so that we can specify contracts in libstd and let an end user opt into turning them on.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>This is an accidentally-stable alias to <code>ptr::copy</code>; use that instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy_nonoverlapping"><a href="#val-copy_nonoverlapping" class="anchor"></a><code><span><span class="keyword">val</span> copy_nonoverlapping : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>This is an accidentally-stable alias to <code>ptr::copy_nonoverlapping</code>; use that instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copysignf128"><a href="#val-copysignf128" class="anchor"></a><code><span><span class="keyword">val</span> copysignf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Copies the sign from <code>y</code> to <code>x</code> for <code>f128</code> values.</p><p>The stabilized version of this intrinsic is <code>f128::copysign</code>(../../std/primitive.f128.html#method.copysign)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copysignf16"><a href="#val-copysignf16" class="anchor"></a><code><span><span class="keyword">val</span> copysignf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Copies the sign from <code>y</code> to <code>x</code> for <code>f16</code> values.</p><p>The stabilized version of this intrinsic is <code>f16::copysign</code>(../../std/primitive.f16.html#method.copysign)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copysignf32"><a href="#val-copysignf32" class="anchor"></a><code><span><span class="keyword">val</span> copysignf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Copies the sign from <code>y</code> to <code>x</code> for <code>f32</code> values.</p><p>The stabilized version of this intrinsic is <code>f32::copysign</code>(../../std/primitive.f32.html#method.copysign)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copysignf64"><a href="#val-copysignf64" class="anchor"></a><code><span><span class="keyword">val</span> copysignf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Copies the sign from <code>y</code> to <code>x</code> for <code>f64</code> values.</p><p>The stabilized version of this intrinsic is <code>f64::copysign</code>(../../std/primitive.f64.html#method.copysign)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosf128"><a href="#val-cosf128" class="anchor"></a><code><span><span class="keyword">val</span> cosf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the cosine of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::cos</code>(../../std/primitive.f128.html#method.cos)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosf16"><a href="#val-cosf16" class="anchor"></a><code><span><span class="keyword">val</span> cosf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the cosine of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::cos</code>(../../std/primitive.f16.html#method.cos)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosf32"><a href="#val-cosf32" class="anchor"></a><code><span><span class="keyword">val</span> cosf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the cosine of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::cos</code>(../../std/primitive.f32.html#method.cos)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosf64"><a href="#val-cosf64" class="anchor"></a><code><span><span class="keyword">val</span> cosf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the cosine of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::cos</code>(../../std/primitive.f64.html#method.cos)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ctlz"><a href="#val-ctlz" class="anchor"></a><code><span><span class="keyword">val</span> ctlz : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the number of leading unset bits (zeroes) in an integer type <code>T</code>.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>leading_zeros</code> method. For example, <code>u32::leading_zeros</code></p><p># Examples</p><p>` #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code></p><p>use std::intrinsics::ctlz;</p><p>let x = 0b0001_1100_u8; let num_leading = ctlz(x); assert_eq!(num_leading, 3); `</p><p>An <code>x</code> with value <code>0</code> will return the bit width of <code>T</code>.</p><p>` #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code></p><p>use std::intrinsics::ctlz;</p><p>let x = 0u16; let num_leading = ctlz(x); assert_eq!(num_leading, 16); `</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ctlz_nonzero"><a href="#val-ctlz_nonzero" class="anchor"></a><code><span><span class="keyword">val</span> ctlz_nonzero : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Like <code>ctlz</code>, but extra-unsafe as it returns <code>undef</code> when given an <code>x</code> with value <code>0</code>.</p><p>This intrinsic does not have a stable counterpart.</p><p># Examples</p><p>` #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code></p><p>use std::intrinsics::ctlz_nonzero;</p><p>let x = 0b0001_1100_u8; let num_leading = unsafe <code> ctlz_nonzero(x) </code>; assert_eq!(num_leading, 3); `</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ctpop"><a href="#val-ctpop" class="anchor"></a><code><span><span class="keyword">val</span> ctpop : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the number of bits set in an integer type <code>T</code></p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>count_ones</code> method. For example, <code>u32::count_ones</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cttz"><a href="#val-cttz" class="anchor"></a><code><span><span class="keyword">val</span> cttz : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the number of trailing unset bits (zeroes) in an integer type <code>T</code>.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>trailing_zeros</code> method. For example, <code>u32::trailing_zeros</code></p><p># Examples</p><p>` #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code></p><p>use std::intrinsics::cttz;</p><p>let x = 0b0011_1000_u8; let num_trailing = cttz(x); assert_eq!(num_trailing, 3); `</p><p>An <code>x</code> with value <code>0</code> will return the bit width of <code>T</code>:</p><p>` #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code></p><p>use std::intrinsics::cttz;</p><p>let x = 0u16; let num_trailing = cttz(x); assert_eq!(num_trailing, 16); `</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cttz_nonzero"><a href="#val-cttz_nonzero" class="anchor"></a><code><span><span class="keyword">val</span> cttz_nonzero : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Like <code>cttz</code>, but extra-unsafe as it returns <code>undef</code> when given an <code>x</code> with value <code>0</code>.</p><p>This intrinsic does not have a stable counterpart.</p><p># Examples</p><p>` #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code></p><p>use std::intrinsics::cttz_nonzero;</p><p>let x = 0b0011_1000_u8; let num_trailing = unsafe <code> cttz_nonzero(x) </code>; assert_eq!(num_trailing, 3); `</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-discriminant_value"><a href="#val-discriminant_value" class="anchor"></a><code><span><span class="keyword">val</span> discriminant_value : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">v</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the value of the discriminant for the variant in 'v'; if <code>T</code> has no discriminant, returns <code>0</code>.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>core::mem::discriminant</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-disjoint_bitor"><a href="#val-disjoint_bitor" class="anchor"></a><code><span><span class="keyword">val</span> disjoint_bitor : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Combine two values which have no bits in common.</p><p>This allows the backend to implement it as <code>a + b</code> *or* <code>a | b</code>, depending which is easier to implement on a specific target.</p><p># Safety</p><p>Requires that <code>(a &amp; b) == 0</code>, or equivalently that <code>(a | b) == (a + b)</code>.</p><p>Otherwise it's immediate UB.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exact_div"><a href="#val-exact_div" class="anchor"></a><code><span><span class="keyword">val</span> exact_div : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs an exact division, resulting in undefined behavior where <code>x % y != 0</code> or <code>y == 0</code> or <code>x == T::MIN &amp;&amp; y == -1</code></p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp2f128"><a href="#val-exp2f128" class="anchor"></a><code><span><span class="keyword">val</span> exp2f128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns 2 raised to the power of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::exp2</code>(../../std/primitive.f128.html#method.exp2)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp2f16"><a href="#val-exp2f16" class="anchor"></a><code><span><span class="keyword">val</span> exp2f16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns 2 raised to the power of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::exp2</code>(../../std/primitive.f16.html#method.exp2)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp2f32"><a href="#val-exp2f32" class="anchor"></a><code><span><span class="keyword">val</span> exp2f32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns 2 raised to the power of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::exp2</code>(../../std/primitive.f32.html#method.exp2)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp2f64"><a href="#val-exp2f64" class="anchor"></a><code><span><span class="keyword">val</span> exp2f64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns 2 raised to the power of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::exp2</code>(../../std/primitive.f64.html#method.exp2)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expf128"><a href="#val-expf128" class="anchor"></a><code><span><span class="keyword">val</span> expf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the exponential of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::exp</code>(../../std/primitive.f128.html#method.exp)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expf16"><a href="#val-expf16" class="anchor"></a><code><span><span class="keyword">val</span> expf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the exponential of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::exp</code>(../../std/primitive.f16.html#method.exp)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expf32"><a href="#val-expf32" class="anchor"></a><code><span><span class="keyword">val</span> expf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the exponential of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::exp</code>(../../std/primitive.f32.html#method.exp)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expf64"><a href="#val-expf64" class="anchor"></a><code><span><span class="keyword">val</span> expf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the exponential of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::exp</code>(../../std/primitive.f64.html#method.exp)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fabsf128"><a href="#val-fabsf128" class="anchor"></a><code><span><span class="keyword">val</span> fabsf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the absolute value of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::abs</code>(../../std/primitive.f128.html#method.abs)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fabsf16"><a href="#val-fabsf16" class="anchor"></a><code><span><span class="keyword">val</span> fabsf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the absolute value of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::abs</code>(../../std/primitive.f16.html#method.abs)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fabsf32"><a href="#val-fabsf32" class="anchor"></a><code><span><span class="keyword">val</span> fabsf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the absolute value of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::abs</code>(../../std/primitive.f32.html#method.abs)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fabsf64"><a href="#val-fabsf64" class="anchor"></a><code><span><span class="keyword">val</span> fabsf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the absolute value of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::abs</code>(../../std/primitive.f64.html#method.abs)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fadd_algebraic"><a href="#val-fadd_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> fadd_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float addition that allows optimizations based on algebraic rules.</p><p>Stabilized as <code>f16::algebraic_add</code>, <code>f32::algebraic_add</code>, <code>f64::algebraic_add</code> and <code>f128::algebraic_add</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fadd_fast"><a href="#val-fadd_fast" class="anchor"></a><code><span><span class="keyword">val</span> fadd_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float addition that allows optimizations based on algebraic rules. May assume inputs are finite.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fdiv_algebraic"><a href="#val-fdiv_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> fdiv_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float division that allows optimizations based on algebraic rules.</p><p>Stabilized as <code>f16::algebraic_div</code>, <code>f32::algebraic_div</code>, <code>f64::algebraic_div</code> and <code>f128::algebraic_div</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fdiv_fast"><a href="#val-fdiv_fast" class="anchor"></a><code><span><span class="keyword">val</span> fdiv_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float division that allows optimizations based on algebraic rules. May assume inputs are finite.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float_to_int_unchecked"><a href="#val-float_to_int_unchecked" class="anchor"></a><code><span><span class="keyword">val</span> float_to_int_unchecked : 
  <span><span class="label">float</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">int</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">value</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Converts with LLVM’s fptoui/fptosi, which may return undef for values out of range (&lt;https://github.com/rust-lang/rust/issues/10184&gt;)</p><p>Stabilized as <code>f32::to_int_unchecked</code> and <code>f64::to_int_unchecked</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floorf128"><a href="#val-floorf128" class="anchor"></a><code><span><span class="keyword">val</span> floorf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the largest integer less than or equal to an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::floor</code>(../../std/primitive.f128.html#method.floor)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floorf16"><a href="#val-floorf16" class="anchor"></a><code><span><span class="keyword">val</span> floorf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the largest integer less than or equal to an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::floor</code>(../../std/primitive.f16.html#method.floor)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floorf32"><a href="#val-floorf32" class="anchor"></a><code><span><span class="keyword">val</span> floorf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the largest integer less than or equal to an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::floor</code>(../../std/primitive.f32.html#method.floor)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floorf64"><a href="#val-floorf64" class="anchor"></a><code><span><span class="keyword">val</span> floorf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the largest integer less than or equal to an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::floor</code>(../../std/primitive.f64.html#method.floor)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmaf128"><a href="#val-fmaf128" class="anchor"></a><code><span><span class="keyword">val</span> fmaf128 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>a * b + c</code> for <code>f128</code> values.</p><p>The stabilized version of this intrinsic is <code>f128::mul_add</code>(../../std/primitive.f128.html#method.mul_add)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmaf16"><a href="#val-fmaf16" class="anchor"></a><code><span><span class="keyword">val</span> fmaf16 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>a * b + c</code> for <code>f16</code> values.</p><p>The stabilized version of this intrinsic is <code>f16::mul_add</code>(../../std/primitive.f16.html#method.mul_add)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmaf32"><a href="#val-fmaf32" class="anchor"></a><code><span><span class="keyword">val</span> fmaf32 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>a * b + c</code> for <code>f32</code> values.</p><p>The stabilized version of this intrinsic is <code>f32::mul_add</code>(../../std/primitive.f32.html#method.mul_add)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmaf64"><a href="#val-fmaf64" class="anchor"></a><code><span><span class="keyword">val</span> fmaf64 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>a * b + c</code> for <code>f64</code> values.</p><p>The stabilized version of this intrinsic is <code>f64::mul_add</code>(../../std/primitive.f64.html#method.mul_add)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmul_algebraic"><a href="#val-fmul_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> fmul_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float multiplication that allows optimizations based on algebraic rules.</p><p>Stabilized as <code>f16::algebraic_mul</code>, <code>f32::algebraic_mul</code>, <code>f64::algebraic_mul</code> and <code>f128::algebraic_mul</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmul_fast"><a href="#val-fmul_fast" class="anchor"></a><code><span><span class="keyword">val</span> fmul_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float multiplication that allows optimizations based on algebraic rules. May assume inputs are finite.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmuladdf128"><a href="#val-fmuladdf128" class="anchor"></a><code><span><span class="keyword">val</span> fmuladdf128 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>a * b + c</code> for <code>f128</code> values, non-deterministically executing either a fused multiply-add or two operations with rounding of the intermediate result.</p><p>The operation is fused if the code generator determines that target instruction set has support for a fused operation, and that the fused operation is more efficient than the equivalent, separate pair of mul and add instructions. It is unspecified whether or not a fused operation is selected, and that may depend on optimization level and context, for example.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmuladdf16"><a href="#val-fmuladdf16" class="anchor"></a><code><span><span class="keyword">val</span> fmuladdf16 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>a * b + c</code> for <code>f16</code> values, non-deterministically executing either a fused multiply-add or two operations with rounding of the intermediate result.</p><p>The operation is fused if the code generator determines that target instruction set has support for a fused operation, and that the fused operation is more efficient than the equivalent, separate pair of mul and add instructions. It is unspecified whether or not a fused operation is selected, and that may depend on optimization level and context, for example.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmuladdf32"><a href="#val-fmuladdf32" class="anchor"></a><code><span><span class="keyword">val</span> fmuladdf32 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>a * b + c</code> for <code>f32</code> values, non-deterministically executing either a fused multiply-add or two operations with rounding of the intermediate result.</p><p>The operation is fused if the code generator determines that target instruction set has support for a fused operation, and that the fused operation is more efficient than the equivalent, separate pair of mul and add instructions. It is unspecified whether or not a fused operation is selected, and that may depend on optimization level and context, for example.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmuladdf64"><a href="#val-fmuladdf64" class="anchor"></a><code><span><span class="keyword">val</span> fmuladdf64 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>a * b + c</code> for <code>f64</code> values, non-deterministically executing either a fused multiply-add or two operations with rounding of the intermediate result.</p><p>The operation is fused if the code generator determines that target instruction set has support for a fused operation, and that the fused operation is more efficient than the equivalent, separate pair of mul and add instructions. It is unspecified whether or not a fused operation is selected, and that may depend on optimization level and context, for example.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-forget"><a href="#val-forget" class="anchor"></a><code><span><span class="keyword">val</span> forget : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">arg</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Moves a value out of scope without running drop glue.</p><p>This exists solely for <code>crate::mem::forget_unsized</code>; normal <code>forget</code> uses <code>ManuallyDrop</code> instead.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-frem_algebraic"><a href="#val-frem_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> frem_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float remainder that allows optimizations based on algebraic rules.</p><p>Stabilized as <code>f16::algebraic_rem</code>, <code>f32::algebraic_rem</code>, <code>f64::algebraic_rem</code> and <code>f128::algebraic_rem</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-frem_fast"><a href="#val-frem_fast" class="anchor"></a><code><span><span class="keyword">val</span> frem_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float remainder that allows optimizations based on algebraic rules. May assume inputs are finite.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fsub_algebraic"><a href="#val-fsub_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> fsub_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float subtraction that allows optimizations based on algebraic rules.</p><p>Stabilized as <code>f16::algebraic_sub</code>, <code>f32::algebraic_sub</code>, <code>f64::algebraic_sub</code> and <code>f128::algebraic_sub</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fsub_fast"><a href="#val-fsub_fast" class="anchor"></a><code><span><span class="keyword">val</span> fsub_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Float subtraction that allows optimizations based on algebraic rules. May assume inputs are finite.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_val_statically_known"><a href="#val-is_val_statically_known" class="anchor"></a><code><span><span class="keyword">val</span> is_val_statically_known : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_arg</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns whether the argument's value is statically known at compile-time.</p><p>This is useful when there is a way of writing the code that will be *faster* when some variables have known values, but *slower* in the general case: an <code>if is_val_statically_known(var)</code> can be used to select between these two variants. The <code>if</code> will be optimized away and only the desired branch remains.</p><p>Formally speaking, this function non-deterministically returns <code>true</code> or <code>false</code>, and the caller has to ensure sound behavior for both cases. In other words, the following code has *Undefined Behavior*:</p><p>`no_run #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code> use std::hint::unreachable_unchecked; use std::intrinsics::is_val_statically_known;</p><p>if !is_val_statically_known(0) <code> unsafe { unreachable_unchecked(); </code></p><p>}</p><p>`</p><p>This also means that the following code's behavior is unspecified; it may panic, or it may not:</p><p>`no_run #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code> use std::intrinsics::is_val_statically_known;</p><p>assert_eq!(is_val_statically_known(0), is_val_statically_known(0)); `</p><p>Unsafe code may not rely on <code>is_val_statically_known</code> returning any particular value, ever. However, the compiler will generally make it return <code>true</code> only if the value of the argument is actually known.</p><p># Stability concerns</p><p>While it is safe to call, this intrinsic may behave differently in a <code>const</code> context than otherwise. See the <code>const_eval_select()</code> documentation for an explanation of the issues this can cause. Unlike <code>const_eval_select</code>, this intrinsic isn't guaranteed to behave deterministically even in a <code>const</code> context.</p><p># Type Requirements</p><p><code>T</code> must be either a <code>bool</code>, a <code>char</code>, a primitive numeric type (e.g. <code>f32</code>, but not <code>NonZeroISize</code>), or any thin pointer (e.g. <code>*mut String</code>). Any other argument types *may* cause a compiler error.</p><p>## Pointers</p><p>When the input is a pointer, only the pointer itself is ever considered. The pointee has no effect. Currently, these functions behave identically:</p><p>` #!<code>feature(core_intrinsics)</code> # #!<code>allow(internal_features)</code> use std::intrinsics::is_val_statically_known;</p><p>fn foo(x: &amp;i32) -&gt; bool <code>
is_val_statically_known(x)
</code></p><p>fn bar(x: &amp;i32) -&gt; bool <code>
is_val_statically_known(
(x as *const i32).addr()
)
</code> # _ = foo(&amp;5_i32); # _ = bar(&amp;5_i32); `</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-likely"><a href="#val-likely" class="anchor"></a><code><span><span class="keyword">val</span> likely : <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</p><p>Any use other than with <code>if</code> statements will probably not have an effect.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log10f128"><a href="#val-log10f128" class="anchor"></a><code><span><span class="keyword">val</span> log10f128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the base 10 logarithm of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::log10</code>(../../std/primitive.f128.html#method.log10)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log10f16"><a href="#val-log10f16" class="anchor"></a><code><span><span class="keyword">val</span> log10f16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the base 10 logarithm of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::log10</code>(../../std/primitive.f16.html#method.log10)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log10f32"><a href="#val-log10f32" class="anchor"></a><code><span><span class="keyword">val</span> log10f32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the base 10 logarithm of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::log10</code>(../../std/primitive.f32.html#method.log10)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log10f64"><a href="#val-log10f64" class="anchor"></a><code><span><span class="keyword">val</span> log10f64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the base 10 logarithm of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::log10</code>(../../std/primitive.f64.html#method.log10)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log2f128"><a href="#val-log2f128" class="anchor"></a><code><span><span class="keyword">val</span> log2f128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the base 2 logarithm of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::log2</code>(../../std/primitive.f128.html#method.log2)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log2f16"><a href="#val-log2f16" class="anchor"></a><code><span><span class="keyword">val</span> log2f16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the base 2 logarithm of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::log2</code>(../../std/primitive.f16.html#method.log2)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log2f32"><a href="#val-log2f32" class="anchor"></a><code><span><span class="keyword">val</span> log2f32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the base 2 logarithm of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::log2</code>(../../std/primitive.f32.html#method.log2)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log2f64"><a href="#val-log2f64" class="anchor"></a><code><span><span class="keyword">val</span> log2f64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the base 2 logarithm of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::log2</code>(../../std/primitive.f64.html#method.log2)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logf128"><a href="#val-logf128" class="anchor"></a><code><span><span class="keyword">val</span> logf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the natural logarithm of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::ln</code>(../../std/primitive.f128.html#method.ln)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logf16"><a href="#val-logf16" class="anchor"></a><code><span><span class="keyword">val</span> logf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the natural logarithm of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::ln</code>(../../std/primitive.f16.html#method.ln)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logf32"><a href="#val-logf32" class="anchor"></a><code><span><span class="keyword">val</span> logf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the natural logarithm of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::ln</code>(../../std/primitive.f32.html#method.ln)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logf64"><a href="#val-logf64" class="anchor"></a><code><span><span class="keyword">val</span> logf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the natural logarithm of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::ln</code>(../../std/primitive.f64.html#method.ln)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximumf128"><a href="#val-maximumf128" class="anchor"></a><code><span><span class="keyword">val</span> maximumf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the maximum (IEEE 754-2019 maximum) of two <code>f128</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximumf16"><a href="#val-maximumf16" class="anchor"></a><code><span><span class="keyword">val</span> maximumf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the maximum (IEEE 754-2019 maximum) of two <code>f16</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximumf32"><a href="#val-maximumf32" class="anchor"></a><code><span><span class="keyword">val</span> maximumf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the maximum (IEEE 754-2019 maximum) of two <code>f32</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximumf64"><a href="#val-maximumf64" class="anchor"></a><code><span><span class="keyword">val</span> maximumf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the maximum (IEEE 754-2019 maximum) of two <code>f64</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maxnumf128"><a href="#val-maxnumf128" class="anchor"></a><code><span><span class="keyword">val</span> maxnumf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the maximum (IEEE 754-2008 maxNum) of two <code>f128</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>f128::max</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maxnumf16"><a href="#val-maxnumf16" class="anchor"></a><code><span><span class="keyword">val</span> maxnumf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the maximum (IEEE 754-2008 maxNum) of two <code>f16</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>f16::max</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maxnumf32"><a href="#val-maxnumf32" class="anchor"></a><code><span><span class="keyword">val</span> maxnumf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the maximum (IEEE 754-2008 maxNum) of two <code>f32</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>f32::max</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maxnumf64"><a href="#val-maxnumf64" class="anchor"></a><code><span><span class="keyword">val</span> maxnumf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the maximum (IEEE 754-2008 maxNum) of two <code>f64</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>f64::max</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minimumf128"><a href="#val-minimumf128" class="anchor"></a><code><span><span class="keyword">val</span> minimumf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the minimum (IEEE 754-2019 minimum) of two <code>f128</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minimumf16"><a href="#val-minimumf16" class="anchor"></a><code><span><span class="keyword">val</span> minimumf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the minimum (IEEE 754-2019 minimum) of two <code>f16</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minimumf32"><a href="#val-minimumf32" class="anchor"></a><code><span><span class="keyword">val</span> minimumf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the minimum (IEEE 754-2019 minimum) of two <code>f32</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minimumf64"><a href="#val-minimumf64" class="anchor"></a><code><span><span class="keyword">val</span> minimumf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the minimum (IEEE 754-2019 minimum) of two <code>f64</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minnumf128"><a href="#val-minnumf128" class="anchor"></a><code><span><span class="keyword">val</span> minnumf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the minimum (IEEE 754-2008 minNum) of two <code>f128</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>f128::min</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minnumf16"><a href="#val-minnumf16" class="anchor"></a><code><span><span class="keyword">val</span> minnumf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the minimum (IEEE 754-2008 minNum) of two <code>f16</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>f16::min</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minnumf32"><a href="#val-minnumf32" class="anchor"></a><code><span><span class="keyword">val</span> minnumf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the minimum (IEEE 754-2008 minNum) of two <code>f32</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>f32::min</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minnumf64"><a href="#val-minnumf64" class="anchor"></a><code><span><span class="keyword">val</span> minnumf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the minimum (IEEE 754-2008 minNum) of two <code>f64</code> values.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized version of this intrinsic is <code>f64::min</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_with_overflow"><a href="#val-mul_with_overflow" class="anchor"></a><code><span><span class="keyword">val</span> mul_with_overflow : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs checked integer multiplication</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>overflowing_mul</code> method. For example, <code>u32::overflowing_mul</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-needs_drop"><a href="#val-needs_drop" class="anchor"></a><code><span><span class="keyword">val</span> needs_drop : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns <code>true</code> if the actual type given as <code>T</code> requires drop glue; returns <code>false</code> if the actual type provided for <code>T</code> implements <code>Copy</code>.</p><p>If the actual type neither requires drop glue nor implements <code>Copy</code>, then the return value of this function is unspecified.</p><p>Note that, unlike most intrinsics, this can only be called at compile-time as backends do not have an implementation for it. The only caller (its stable counterpart) wraps this intrinsic call in a <code>const</code> block so that backends only see an evaluated constant.</p><p>The stabilized version of this intrinsic is <code>mem::needs_drop</code>(crate::mem::needs_drop).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nontemporal_store"><a href="#val-nontemporal_store" class="anchor"></a><code><span><span class="keyword">val</span> nontemporal_store : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Emits a <code>nontemporal</code> store, which gives a hint to the CPU that the data should not be held in cache. Except for performance, this is fully equivalent to <code>ptr.write(val)</code>.</p><p>Not all architectures provide such an operation. For instance, x86 does not: while <code>MOVNT</code> exists, that operation is *not* equivalent to <code>ptr.write(val)</code> (<code>MOVNT</code> writes can be reordered in ways that are not allowed for regular writes).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-offset"><a href="#val-offset" class="anchor"></a><code><span><span class="keyword">val</span> offset : 
  <span><span class="label">ptr</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">delta</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">offset</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Calculates the offset from a pointer.</p><p>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.</p><p>This can only be used with <code>Ptr</code> as a raw pointer type (<code>*mut</code> or <code>*const</code>) to a <code>Sized</code> pointee and with <code>Delta</code> as <code>usize</code> or <code>isize</code>. Any other instantiations may arbitrarily misbehave, and that's *not* a compiler bug.</p><p># Safety</p><p>If the computed offset is non-zero, then both the starting and resulting pointer must be either in bounds or at the end of an allocation. If either pointer is out of bounds or arithmetic overflow occurs then this operation is undefined behavior.</p><p>The stabilized version of this intrinsic is <code>pointer::offset</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powf128"><a href="#val-powf128" class="anchor"></a><code><span><span class="keyword">val</span> powf128 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Raises an <code>f128</code> to an <code>f128</code> power.</p><p>The stabilized version of this intrinsic is <code>f128::powf</code>(../../std/primitive.f128.html#method.powf)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powf16"><a href="#val-powf16" class="anchor"></a><code><span><span class="keyword">val</span> powf16 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Raises an <code>f16</code> to an <code>f16</code> power.</p><p>The stabilized version of this intrinsic is <code>f16::powf</code>(../../std/primitive.f16.html#method.powf)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powf32"><a href="#val-powf32" class="anchor"></a><code><span><span class="keyword">val</span> powf32 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Raises an <code>f32</code> to an <code>f32</code> power.</p><p>The stabilized version of this intrinsic is <code>f32::powf</code>(../../std/primitive.f32.html#method.powf)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powf64"><a href="#val-powf64" class="anchor"></a><code><span><span class="keyword">val</span> powf64 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Raises an <code>f64</code> to an <code>f64</code> power.</p><p>The stabilized version of this intrinsic is <code>f64::powf</code>(../../std/primitive.f64.html#method.powf)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powif128"><a href="#val-powif128" class="anchor"></a><code><span><span class="keyword">val</span> powif128 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Raises an <code>f128</code> to an integer power.</p><p>The stabilized version of this intrinsic is <code>f128::powi</code>(../../std/primitive.f128.html#method.powi)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powif16"><a href="#val-powif16" class="anchor"></a><code><span><span class="keyword">val</span> powif16 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Raises an <code>f16</code> to an integer power.</p><p>The stabilized version of this intrinsic is <code>f16::powi</code>(../../std/primitive.f16.html#method.powi)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powif32"><a href="#val-powif32" class="anchor"></a><code><span><span class="keyword">val</span> powif32 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Raises an <code>f32</code> to an integer power.</p><p>The stabilized version of this intrinsic is <code>f32::powi</code>(../../std/primitive.f32.html#method.powi)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powif64"><a href="#val-powif64" class="anchor"></a><code><span><span class="keyword">val</span> powif64 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Raises an <code>f64</code> to an integer power.</p><p>The stabilized version of this intrinsic is <code>f64::powi</code>(../../std/primitive.f64.html#method.powi)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefetch_read_data"><a href="#val-prefetch_read_data" class="anchor"></a><code><span><span class="keyword">val</span> prefetch_read_data : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">locality</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The <code>prefetch</code> intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</p><p>The <code>locality</code> argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefetch_read_instruction"><a href="#val-prefetch_read_instruction" class="anchor"></a><code><span><span class="keyword">val</span> prefetch_read_instruction : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">locality</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The <code>prefetch</code> intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</p><p>The <code>locality</code> argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefetch_write_data"><a href="#val-prefetch_write_data" class="anchor"></a><code><span><span class="keyword">val</span> prefetch_write_data : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">locality</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The <code>prefetch</code> intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</p><p>The <code>locality</code> argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefetch_write_instruction"><a href="#val-prefetch_write_instruction" class="anchor"></a><code><span><span class="keyword">val</span> prefetch_write_instruction : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">locality</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The <code>prefetch</code> intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</p><p>The <code>locality</code> argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_guaranteed_cmp"><a href="#val-ptr_guaranteed_cmp" class="anchor"></a><code><span><span class="keyword">val</span> ptr_guaranteed_cmp : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">other</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>See documentation of <code>&lt;*const T&gt;::guaranteed_eq</code> for details. Returns <code>2</code> if the result is unknown. Returns <code>1</code> if the pointers are guaranteed equal. Returns <code>0</code> if the pointers are guaranteed inequal.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_mask"><a href="#val-ptr_mask" class="anchor"></a><code><span><span class="keyword">val</span> ptr_mask : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">mask</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Masks out bits of the pointer according to a mask.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>Consider using <code>pointer::mask</code> instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_metadata"><a href="#val-ptr_metadata" class="anchor"></a><code><span><span class="keyword">val</span> ptr_metadata : 
  <span><span class="label">p</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">m</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Lowers in MIR to <code>Rvalue::UnaryOp</code> with <code>UnOp::PtrMetadata</code>.</p><p>This is used to implement functions like <code>ptr::metadata</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_offset_from"><a href="#val-ptr_offset_from" class="anchor"></a><code><span><span class="keyword">val</span> ptr_offset_from : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">base</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>See documentation of <code>&lt;*const T&gt;::offset_from</code> for details.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_offset_from_unsigned"><a href="#val-ptr_offset_from_unsigned" class="anchor"></a><code><span><span class="keyword">val</span> ptr_offset_from_unsigned : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">base</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>See documentation of <code>&lt;*const T&gt;::offset_from_unsigned</code> for details.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-raw_eq"><a href="#val-raw_eq" class="anchor"></a><code><span><span class="keyword">val</span> raw_eq : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Determines whether the raw bytes of the two values are equal.</p><p>This is particularly handy for arrays, since it allows things like just comparing <code>i96</code>s instead of forcing <code>alloca</code>s for <code>[6 x i16]</code>.</p><p>Above some backend-decided threshold this will emit calls to <code>memcmp</code>, like slice equality does, instead of causing massive code size.</p><p>Since this works by comparing the underlying bytes, the actual <code>T</code> is not particularly important. It will be used for its size and alignment, but any validity restrictions will be ignored, not enforced.</p><p># Safety</p><p>It's UB to call this if any of the *bytes* in <code>*a</code> or <code>*b</code> are uninitialized. Note that this is a stricter criterion than just the *values* being fully-initialized: if <code>T</code> has padding, it's UB to call this intrinsic.</p><p>At compile-time, it is furthermore UB to call this if any of the bytes in <code>*a</code> or <code>*b</code> have provenance.</p><p>(The implementation is allowed to branch on the results of comparisons, which is UB if any of their inputs are <code>undef</code>.)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_via_copy"><a href="#val-read_via_copy" class="anchor"></a><code><span><span class="keyword">val</span> read_via_copy : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>This is an implementation detail of <code>crate::ptr::read</code> and should not be used anywhere else. See its comments for why this exists.</p><p>This intrinsic can *only* be called where the pointer is a local without projections (<code>read_via_copy(ptr)</code>, not <code>read_via_copy( *ptr)</code>) so that it trivially obeys runtime-MIR rules about derefs in operands.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rotate_left"><a href="#val-rotate_left" class="anchor"></a><code><span><span class="keyword">val</span> rotate_left : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">shift</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs rotate left.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>rotate_left</code> method. For example, <code>u32::rotate_left</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rotate_right"><a href="#val-rotate_right" class="anchor"></a><code><span><span class="keyword">val</span> rotate_right : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">shift</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs rotate right.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>rotate_right</code> method. For example, <code>u32::rotate_right</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-round_ties_even_f128"><a href="#val-round_ties_even_f128" class="anchor"></a><code><span><span class="keyword">val</span> round_ties_even_f128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the nearest integer to an <code>f128</code>. Rounds half-way cases to the number with an even least significant digit.</p><p>The stabilized version of this intrinsic is <code>f128::round_ties_even</code>(../../std/primitive.f128.html#method.round_ties_even)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-round_ties_even_f16"><a href="#val-round_ties_even_f16" class="anchor"></a><code><span><span class="keyword">val</span> round_ties_even_f16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the nearest integer to an <code>f16</code>. Rounds half-way cases to the number with an even least significant digit.</p><p>The stabilized version of this intrinsic is <code>f16::round_ties_even</code>(../../std/primitive.f16.html#method.round_ties_even)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-round_ties_even_f32"><a href="#val-round_ties_even_f32" class="anchor"></a><code><span><span class="keyword">val</span> round_ties_even_f32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the nearest integer to an <code>f32</code>. Rounds half-way cases to the number with an even least significant digit.</p><p>The stabilized version of this intrinsic is <code>f32::round_ties_even</code>(../../std/primitive.f32.html#method.round_ties_even)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-round_ties_even_f64"><a href="#val-round_ties_even_f64" class="anchor"></a><code><span><span class="keyword">val</span> round_ties_even_f64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the nearest integer to an <code>f64</code>. Rounds half-way cases to the number with an even least significant digit.</p><p>The stabilized version of this intrinsic is <code>f64::round_ties_even</code>(../../std/primitive.f64.html#method.round_ties_even)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundf128"><a href="#val-roundf128" class="anchor"></a><code><span><span class="keyword">val</span> roundf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the nearest integer to an <code>f128</code>. Rounds half-way cases away from zero.</p><p>The stabilized version of this intrinsic is <code>f128::round</code>(../../std/primitive.f128.html#method.round)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundf16"><a href="#val-roundf16" class="anchor"></a><code><span><span class="keyword">val</span> roundf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the nearest integer to an <code>f16</code>. Rounds half-way cases away from zero.</p><p>The stabilized version of this intrinsic is <code>f16::round</code>(../../std/primitive.f16.html#method.round)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundf32"><a href="#val-roundf32" class="anchor"></a><code><span><span class="keyword">val</span> roundf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the nearest integer to an <code>f32</code>. Rounds half-way cases away from zero.</p><p>The stabilized version of this intrinsic is <code>f32::round</code>(../../std/primitive.f32.html#method.round)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundf64"><a href="#val-roundf64" class="anchor"></a><code><span><span class="keyword">val</span> roundf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the nearest integer to an <code>f64</code>. Rounds half-way cases away from zero.</p><p>The stabilized version of this intrinsic is <code>f64::round</code>(../../std/primitive.f64.html#method.round)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rustc_peek"><a href="#val-rustc_peek" class="anchor"></a><code><span><span class="keyword">val</span> rustc_peek : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">arg</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Magic intrinsic that derives its meaning from attributes attached to the function.</p><p>For example, dataflow uses this to inject static assertions so that <code>rustc_peek(potentially_uninitialized)</code> would actually double-check that dataflow did indeed compute that it is uninitialized at that point in the control flow.</p><p>This intrinsic should not be used outside of the compiler.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-saturating_add"><a href="#val-saturating_add" class="anchor"></a><code><span><span class="keyword">val</span> saturating_add : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Computes <code>a + b</code>, saturating at numeric bounds.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>saturating_add</code> method. For example, <code>u32::saturating_add</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-saturating_sub"><a href="#val-saturating_sub" class="anchor"></a><code><span><span class="keyword">val</span> saturating_sub : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Computes <code>a - b</code>, saturating at numeric bounds.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>saturating_sub</code> method. For example, <code>u32::saturating_sub</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-select_unpredictable"><a href="#val-select_unpredictable" class="anchor"></a><code><span><span class="keyword">val</span> select_unpredictable : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">true_val</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">false_val</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns either <code>true_val</code> or <code>false_val</code> depending on condition <code>b</code> with a hint to the compiler that this condition is unlikely to be correctly predicted by a CPU's branch predictor (e.g. a binary search).</p><p>This is otherwise functionally equivalent to <code>if b { true_val } else { false_val }</code>.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The public form of this intrinsic is <code>core::hint::select_unpredictable</code>. However unlike the public form, the intrinsic will not drop the value that is not selected.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinf128"><a href="#val-sinf128" class="anchor"></a><code><span><span class="keyword">val</span> sinf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the sine of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::sin</code>(../../std/primitive.f128.html#method.sin)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinf16"><a href="#val-sinf16" class="anchor"></a><code><span><span class="keyword">val</span> sinf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the sine of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::sin</code>(../../std/primitive.f16.html#method.sin)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinf32"><a href="#val-sinf32" class="anchor"></a><code><span><span class="keyword">val</span> sinf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the sine of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::sin</code>(../../std/primitive.f32.html#method.sin)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinf64"><a href="#val-sinf64" class="anchor"></a><code><span><span class="keyword">val</span> sinf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the sine of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::sin</code>(../../std/primitive.f64.html#method.sin)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_of"><a href="#val-size_of" class="anchor"></a><code><span><span class="keyword">val</span> size_of : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The size of a type in bytes.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>More specifically, this is the offset in bytes between successive items of the same type, including alignment padding.</p><p>The stabilized version of this intrinsic is <code>size_of</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_of_val"><a href="#val-size_of_val" class="anchor"></a><code><span><span class="keyword">val</span> size_of_val : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The size of the referenced value in bytes.</p><p>The stabilized version of this intrinsic is <code>size_of_val</code>.</p><p># Safety</p><p>See <code>crate::mem::size_of_val_raw</code> for safety conditions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slice_get_unchecked"><a href="#val-slice_get_unchecked" class="anchor"></a><code><span><span class="keyword">val</span> slice_get_unchecked : 
  <span><span class="label">itemptr</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sliceptr</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">slice_ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">index</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Projects to the <code>index</code>-th element of <code>slice_ptr</code>, as the same kind of pointer as the slice was provided -- so <code>&amp;mut [T] → &amp;mut T</code>, <code>&amp;[T] → &amp;T</code>, <code>*mut [T] → *mut T</code>, or <code>*const [T] → *const T</code> -- without a bounds check.</p><p>This is exposed via <code>&lt;usize as SliceIndex&gt;::get(_unchecked)(_mut)</code>, and isn't intended to be used elsewhere.</p><p>Expands in MIR to <code>{&amp;, &amp;mut, &amp;raw const, &amp;raw mut} ( *slice_ptr)[index]</code>, depending on the types involved, so no backend support is needed.</p><p># Safety</p><ul><li><code>index &lt; PtrMetadata(slice_ptr)</code>, so the indexing is in-bounds for the slice</li><li>the resulting offsetting is in-bounds of the allocated object, which is always the case for references, but needs to be upheld manually for pointers</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrtf128"><a href="#val-sqrtf128" class="anchor"></a><code><span><span class="keyword">val</span> sqrtf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the square root of an <code>f128</code></p><p>The stabilized version of this intrinsic is <code>f128::sqrt</code>(../../std/primitive.f128.html#method.sqrt)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrtf16"><a href="#val-sqrtf16" class="anchor"></a><code><span><span class="keyword">val</span> sqrtf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the square root of an <code>f16</code></p><p>The stabilized version of this intrinsic is <code>f16::sqrt</code>(../../std/primitive.f16.html#method.sqrt)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrtf32"><a href="#val-sqrtf32" class="anchor"></a><code><span><span class="keyword">val</span> sqrtf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the square root of an <code>f32</code></p><p>The stabilized version of this intrinsic is <code>f32::sqrt</code>(../../std/primitive.f32.html#method.sqrt)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrtf64"><a href="#val-sqrtf64" class="anchor"></a><code><span><span class="keyword">val</span> sqrtf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the square root of an <code>f64</code></p><p>The stabilized version of this intrinsic is <code>f64::sqrt</code>(../../std/primitive.f64.html#method.sqrt)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub_with_overflow"><a href="#val-sub_with_overflow" class="anchor"></a><code><span><span class="keyword">val</span> sub_with_overflow : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs checked integer subtraction</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>overflowing_sub</code> method. For example, <code>u32::overflowing_sub</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-three_way_compare"><a href="#val-three_way_compare" class="anchor"></a><code><span><span class="keyword">val</span> three_way_compare : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">lhs</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">rhss</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Does a three-way comparison between the two arguments, which must be of character or integer (signed or unsigned) type.</p><p>This was originally added because it greatly simplified the MIR in <code>cmp</code> implementations, and then LLVM 20 added a backend intrinsic for it too.</p><p>The stabilized version of this intrinsic is <code>Ord::cmp</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-transmute"><a href="#val-transmute" class="anchor"></a><code><span><span class="keyword">val</span> transmute : 
  <span><span class="label">t_src</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Reinterprets the bits of a value of one type as another type.</p><p>Both types must have the same size. Compilation will fail if this is not guaranteed.</p><p><code>transmute</code> is semantically equivalent to a bitwise move of one type into another. It copies the bits from the source value into the destination value, then forgets the original. Note that source and destination are passed by-value, which means if <code>Src</code> or <code>Dst</code> contain padding, that padding is *not* guaranteed to be preserved by <code>transmute</code>.</p><p>Both the argument and the result must be <code>valid</code>(../../nomicon/what-unsafe-does.html) at their given type. Violating this condition leads to <code>undefined behavior</code><code>ub</code>. The compiler will generate code *assuming that you, the programmer, ensure that there will never be undefined behavior*. It is therefore your responsibility to guarantee that every value passed to <code>transmute</code> is valid at both types <code>Src</code> and <code>Dst</code>. Failing to uphold this condition may lead to unexpected and unstable compilation results. This makes <code>transmute</code> **incredibly unsafe**. <code>transmute</code> should be the absolute last resort.</p><p>Because <code>transmute</code> is a by-value operation, alignment of the *transmuted values themselves* is not a concern. As with any other function, the compiler already ensures both <code>Src</code> and <code>Dst</code> are properly aligned. However, when transmuting values that *point elsewhere* (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values.</p><p>The <code>nomicon</code>(../../nomicon/transmutes.html) has additional documentation.</p><p><code>ub</code>: ../../reference/behavior-considered-undefined.html</p><p># Transmutation between pointers and integers</p><p>Special care has to be taken when transmuting between pointers and integers, e.g. transmuting between <code>*const ()</code> and <code>usize</code>.</p><p>Transmuting *pointers to integers* in a <code>const</code> context is <code>undefined behavior</code><code>ub</code>, unless the pointer was originally created *from* an integer. (That includes this function specifically, integer-to-pointer casts, and helpers like <code>dangling</code><code>crate::ptr::dangling</code>, but also semantically-equivalent conversions such as punning through <code>repr(C)</code> union fields.) Any attempt to use the resulting value for integer operations will abort const-evaluation. (And even outside <code>const</code>, such transmutation is touching on many unspecified aspects of the Rust memory model and should be avoided. See below for alternatives.)</p><p>Transmuting *integers to pointers* is a largely unspecified operation. It is likely *not* equivalent to an <code>as</code> cast. Doing non-zero-sized memory accesses with a pointer constructed this way is currently considered undefined behavior.</p><p>All this also applies when the integer is nested inside an array, tuple, struct, or enum. However, <code>MaybeUninit&lt;usize&gt;</code> is not considered an integer type for the purpose of this section. Transmuting <code>*const ()</code> to <code>MaybeUninit&lt;usize&gt;</code> is fine---but then calling <code>assume_init()</code> on that result is considered as completing the pointer-to-integer transmute and thus runs into the issues discussed above.</p><p>In particular, doing a pointer-to-integer-to-pointer roundtrip via <code>transmute</code> is *not* a lossless process. If you want to round-trip a pointer through an integer in a way that you can get back the original pointer, you need to use <code>as</code> casts, or replace the integer type by <code>MaybeUninit&lt;$int&gt;</code> (and never call <code>assume_init()</code>). If you are looking for a way to store data of arbitrary type, also use <code>MaybeUninit&lt;T&gt;</code> (that will also handle uninitialized memory due to padding). If you specifically need to store something that is &quot;either an integer or a pointer&quot;, use <code>*mut ()</code>: integers can be converted to pointers and back without any loss (via <code>as</code> casts or via <code>transmute</code>).</p><p># Examples</p><p>There are a few things that <code>transmute</code> is really useful for.</p><p>Turning a pointer into a function pointer. This is *not* portable to machines where function pointers and data pointers have different sizes.</p><p>` fn foo() -&gt; i32 <code>
0
</code> // Crucially, we <code>as</code>-cast to a raw pointer before <code>transmute</code>ing to a function pointer. // This avoids an integer-to-pointer <code>transmute</code>, which can be problematic. // Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine. let pointer = foo as *const (); let function = unsafe <code>
std::mem::transmute::&lt;*const (), fn() -&gt; i32&gt;(pointer)
</code>; assert_eq!(function(), 0); `</p><p>Extending a lifetime, or shortening an invariant lifetime. This is advanced, very unsafe Rust!</p><p>` struct R&lt;'a&gt;(&amp;'a i32); unsafe fn extend_lifetime&lt;'b&gt;(r: R&lt;'b&gt;) -&gt; R&lt;'static&gt; <code>
unsafe { std::mem::transmute::&lt;R&lt;'b&gt;, R&lt;'static&gt;&gt;(r) </code></p><p>}</p><p>unsafe fn shorten_invariant_lifetime&lt;'b, 'c&gt;(r: &amp;'b mut R&lt;'static&gt;) -&gt; &amp;'b mut R&lt;'c&gt; <code>
unsafe { std::mem::transmute::&lt;&amp;'b mut R&lt;'static&gt;, &amp;'b mut R&lt;'c&gt;&gt;(r) </code></p><p>}</p><p>`</p><p># Alternatives</p><p>Don't despair: many uses of <code>transmute</code> can be achieved through other means. Below are common applications of <code>transmute</code> which can be replaced with safer constructs.</p><p>Turning raw bytes (<code>[u8; SZ]</code>) into <code>u32</code>, <code>f64</code>, etc.:</p><p>` # #!<code>allow(unnecessary_transmutes)</code> let raw_bytes = <code>0x78, 0x56, 0x34, 0x12</code>;</p><p>let num = unsafe <code>
std::mem::transmute::&lt;[u8; 4], u32&gt;(raw_bytes)
</code>;</p><p>// use <code>u32::from_ne_bytes</code> instead let num = u32::from_ne_bytes(raw_bytes); // or use <code>u32::from_le_bytes</code> or <code>u32::from_be_bytes</code> to specify the endianness let num = u32::from_le_bytes(raw_bytes); assert_eq!(num, 0x12345678); let num = u32::from_be_bytes(raw_bytes); assert_eq!(num, 0x78563412); `</p><p>Turning a pointer into a <code>usize</code>:</p><p>`no_run let ptr = &amp;0; let ptr_num_transmute = unsafe <code>
std::mem::transmute::&lt;&amp;i32, usize&gt;(ptr)
</code>;</p><p>// Use an <code>as</code> cast instead let ptr_num_cast = ptr as *const i32 as usize; `</p><p>Note that using <code>transmute</code> to turn a pointer to a <code>usize</code> is (as noted above) <code>undefined behavior</code><code>ub</code> in <code>const</code> contexts. Also outside of consts, this operation might not behave as expected -- this is touching on many unspecified aspects of the Rust memory model. Depending on what the code is doing, the following alternatives are preferable to pointer-to-integer transmutation:</p><ul><li>If the code just wants to store data of arbitrary type in some buffer and needs to pick a type for that buffer, it can use <code>MaybeUninit</code><code>crate::mem::MaybeUninit</code>.</li><li>If the code actually wants to work on the address the pointer points to, it can use <code>as</code> casts or <code>ptr.addr()</code><code>pointer::addr</code>.</li></ul><p>Turning a <code>*mut T</code> into a <code>&amp;mut T</code>:</p><p>` let ptr: *mut i32 = &amp;mut 0; let ref_transmuted = unsafe <code>
std::mem::transmute::&lt;*mut i32, &amp;mut i32&gt;(ptr)
</code>;</p><p>// Use a reborrow instead let ref_casted = unsafe <code> &amp;mut *ptr </code>; `</p><p>Turning a <code>&amp;mut T</code> into a <code>&amp;mut U</code>:</p><p>` let ptr = &amp;mut 0; let val_transmuted = unsafe <code>
std::mem::transmute::&lt;&amp;mut i32, &amp;mut u32&gt;(ptr)
</code>;</p><p>// Now, put together <code>as</code> and reborrowing - note the chaining of <code>as</code> // <code>as</code> is not transitive let val_casts = unsafe <code> &amp;mut *(ptr as *mut i32 as *mut u32) </code>; `</p><p>Turning a <code>&amp;str</code> into a <code>&amp;[u8]</code>:</p><p>` // this is not a good way to do this. let slice = unsafe <code> std::mem::transmute::&lt;&amp;str, &amp;[u8]&gt;(&quot;Rust&quot;) </code>; assert_eq!(slice, &amp;<code>82, 117, 115, 116</code>);</p><p>// You could use <code>str::as_bytes</code> let slice = &quot;Rust&quot;.as_bytes(); assert_eq!(slice, &amp;<code>82, 117, 115, 116</code>);</p><p>// Or, just use a byte string, if you have control over the string // literal assert_eq!(b&quot;Rust&quot;, &amp;<code>82, 117, 115, 116</code>); `</p><p>Turning a <code>Vec&lt;&amp;T&gt;</code> into a <code>Vec&lt;Option&lt;&amp;T&gt;&gt;</code>.</p><p>To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants. For <code>Vec</code>, this means that both the size *and alignment* of the inner types have to match. Other containers might rely on the size of the type, alignment, or even the <code>TypeId</code>, in which case transmuting wouldn't be possible at all without violating the container invariants.</p><p>` let store = <code>0, 1, 2, 3</code>; let v_orig = store.iter().collect::&lt;Vec&lt;&amp;i32&gt;&gt;();</p><p>// clone the vector as we will reuse them later let v_clone = v_orig.clone();</p><p>// Using transmute: this relies on the unspecified data layout of <code>Vec</code>, which is a // bad idea and could cause Undefined Behavior. // However, it is no-copy. let v_transmuted = unsafe <code>
std::mem::transmute::&lt;Vec&lt;&amp;i32&gt;, Vec&lt;Option&lt;&amp;i32&gt;&gt;&gt;(v_clone)
</code>;</p><p>let v_clone = v_orig.clone();</p><p>// This is the suggested, safe way. // It may copy the entire vector into a new one though, but also may not. let v_collected = v_clone.into_iter() .map(Some) .collect::&lt;Vec&lt;Option&lt;&amp;i32&gt;&gt;&gt;();</p><p>let v_clone = v_orig.clone();</p><p>// This is the proper no-copy, unsafe way of &quot;transmuting&quot; a <code>Vec</code>, without relying on the // data layout. Instead of literally calling <code>transmute</code>, we perform a pointer cast, but // in terms of converting the original inner type (<code>&amp;i32</code>) to the new one (<code>Option&lt;&amp;i32&gt;</code>), // this has all the same caveats. Besides the information provided above, also consult the // <code>from_raw_parts</code> documentation. let v_from_raw = unsafe <code>
// Ensure the original vector is not dropped.
let mut v_clone = std::mem::ManuallyDrop::new(v_clone);
Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option&lt;&amp;i32&gt;,
v_clone.len(),
v_clone.capacity())
</code>; `</p><p><code>from_raw_parts</code>: ../../std/vec/struct.Vec.html#method.from_raw_parts</p><p>Implementing <code>split_at_mut</code>:</p><p>` use std::<code>slice, mem</code>;</p><p>// There are multiple ways to do this, and there are multiple problems // with the following (transmute) way. fn split_at_mut_transmute&lt;T&gt;(slice: &amp;mut <code>T</code>, mid: usize) -&gt; (&amp;mut <code>T</code>, &amp;mut <code>T</code>) <code>
let len = slice.len();
assert!(mid &lt;= len);
unsafe {
let slice2 = mem::transmute::&lt;&amp;mut [T], &amp;mut [T]&gt;(slice);
// first: transmute is not type safe; all it checks is that T and
// U are of the same size. Second, right here, you have two
// mutable references pointing to the same memory.
(&amp;mut slice[0..mid], &amp;mut slice2[mid..len])
</code></p><p>}</p><p>// This gets rid of the type safety problems; <code>&amp;mut *</code> will *only* give // you a <code>&amp;mut T</code> from a <code>&amp;mut T</code> or <code>*mut T</code>. fn split_at_mut_casts&lt;T&gt;(slice: &amp;mut <code>T</code>, mid: usize) -&gt; (&amp;mut <code>T</code>, &amp;mut <code>T</code>) <code>
let len = slice.len();
assert!(mid &lt;= len);
unsafe {
let slice2 = &amp;mut *(slice as *mut [T]);
// however, you still have two mutable references pointing to
// the same memory.
(&amp;mut slice[0..mid], &amp;mut slice2[mid..len])
</code></p><p>}</p><p>// This is how the standard library does it. This is the best method, if // you need to do something like this fn split_at_stdlib&lt;T&gt;(slice: &amp;mut <code>T</code>, mid: usize) -&gt; (&amp;mut <code>T</code>, &amp;mut <code>T</code>) <code>
let len = slice.len();
assert!(mid &lt;= len);
unsafe {
let ptr = slice.as_mut_ptr();
// This now has three mutable references pointing at the same
// memory. [slice], the rvalue ret.0, and the rvalue ret.1.
// [slice] is never used after [let ptr = ...], and so one can
// treat it as &quot;dead&quot;, and therefore, you only have two real
// mutable slices.
(slice::from_raw_parts_mut(ptr, mid),
slice::from_raw_parts_mut(ptr.add(mid), len - mid))
</code></p><p>}</p><p>`</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-transmute_unchecked"><a href="#val-transmute_unchecked" class="anchor"></a><code><span><span class="keyword">val</span> transmute_unchecked : 
  <span><span class="label">t_src</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Like <code>transmute</code>, but even less checked at compile-time: rather than giving an error for <code>size_of::&lt;Src&gt;() != size_of::&lt;Dst&gt;()</code>, it's **Undefined Behavior** at runtime.</p><p>Prefer normal <code>transmute</code> where possible, for the extra checking, since both do exactly the same thing at runtime, if they both compile.</p><p>This is not expected to ever be exposed directly to users, rather it may eventually be exposed through some more-constrained API.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncf128"><a href="#val-truncf128" class="anchor"></a><code><span><span class="keyword">val</span> truncf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the integer part of an <code>f128</code>.</p><p>The stabilized version of this intrinsic is <code>f128::trunc</code>(../../std/primitive.f128.html#method.trunc)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncf16"><a href="#val-truncf16" class="anchor"></a><code><span><span class="keyword">val</span> truncf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the integer part of an <code>f16</code>.</p><p>The stabilized version of this intrinsic is <code>f16::trunc</code>(../../std/primitive.f16.html#method.trunc)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncf32"><a href="#val-truncf32" class="anchor"></a><code><span><span class="keyword">val</span> truncf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the integer part of an <code>f32</code>.</p><p>The stabilized version of this intrinsic is <code>f32::trunc</code>(../../std/primitive.f32.html#method.trunc)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncf64"><a href="#val-truncf64" class="anchor"></a><code><span><span class="keyword">val</span> truncf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the integer part of an <code>f64</code>.</p><p>The stabilized version of this intrinsic is <code>f64::trunc</code>(../../std/primitive.f64.html#method.trunc)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_id"><a href="#val-type_id" class="anchor"></a><code><span><span class="keyword">val</span> type_id : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Gets an identifier which is globally unique to the specified type. This function will return the same value for a type regardless of whichever crate it is invoked in.</p><p>Note that, unlike most intrinsics, this can only be called at compile-time as backends do not have an implementation for it. The only caller (its stable counterpart) wraps this intrinsic call in a <code>const</code> block so that backends only see an evaluated constant.</p><p>The stabilized version of this intrinsic is <code>core::any::TypeId::of</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_name"><a href="#val-type_name" class="anchor"></a><code><span><span class="keyword">val</span> type_name : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Gets a static string slice containing the name of a type.</p><p>Note that, unlike most intrinsics, this can only be called at compile-time as backends do not have an implementation for it. The only caller (its stable counterpart) wraps this intrinsic call in a <code>const</code> block so that backends only see an evaluated constant.</p><p>The stabilized version of this intrinsic is <code>core::any::type_name</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typed_swap_nonoverlapping"><a href="#val-typed_swap_nonoverlapping" class="anchor"></a><code><span><span class="keyword">val</span> typed_swap_nonoverlapping : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Non-overlapping *typed* swap of a single value.</p><p>The codegen backends will replace this with a better implementation when <code>T</code> is a simple type that can be loaded and stored as an immediate.</p><p>The stabilized form of this intrinsic is <code>crate::mem::swap</code>.</p><p># Safety Behavior is undefined if any of the following conditions are violated:</p><p>* Both <code>x</code> and <code>y</code> must be <code>valid</code> for both reads and writes.</p><p>* Both <code>x</code> and <code>y</code> must be properly aligned.</p><p>* The region of memory beginning at <code>x</code> must *not* overlap with the region of memory beginning at <code>y</code>.</p><p>* The memory pointed by <code>x</code> and <code>y</code> must both contain values of type <code>T</code>.</p><p><code>valid</code>: crate::ptr#safety</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ub_checks"><a href="#val-ub_checks" class="anchor"></a><code><span><span class="keyword">val</span> ub_checks : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns whether we should perform some UB-checking at runtime. This eventually evaluates to <code>cfg!(ub_checks)</code>, but behaves different from <code>cfg!</code> when mixing crates built with different flags: if the crate has UB checks enabled or carries the <code>#[rustc_preserve_ub_checks]</code> attribute, evaluation is delayed until monomorphization (or until the call gets inlined into a crate that does not delay evaluation further); otherwise it can happen any time.</p><p>The common case here is a user program built with ub_checks linked against the distributed sysroot which is built without ub_checks but with <code>#[rustc_preserve_ub_checks]</code>. For code that gets monomorphized in the user crate (i.e., generic functions and functions with <code>#[inline]</code>), gating assertions on <code>ub_checks()</code> rather than <code>cfg!(ub_checks)</code> means that assertions are enabled whenever the *user crate* has UB checks enabled. However, if the user has UB checks disabled, the checks will still get optimized out. This intrinsic is primarily used by <code>crate::ub_checks::assert_unsafe_precondition</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unaligned_volatile_load"><a href="#val-unaligned_volatile_load" class="anchor"></a><code><span><span class="keyword">val</span> unaligned_volatile_load : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs a volatile load from the <code>src</code> pointer The pointer is not required to be aligned.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unaligned_volatile_store"><a href="#val-unaligned_volatile_store" class="anchor"></a><code><span><span class="keyword">val</span> unaligned_volatile_store : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs a volatile store to the <code>dst</code> pointer. The pointer is not required to be aligned.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_add"><a href="#val-unchecked_add" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_add : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the result of an unchecked addition, resulting in undefined behavior when <code>x + y &gt; T::MAX</code> or <code>x + y &lt; T::MIN</code>.</p><p>The stable counterpart of this intrinsic is <code>unchecked_add</code> on the various integer types, such as <code>u16::unchecked_add</code> and <code>i64::unchecked_add</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_div"><a href="#val-unchecked_div" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_div : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs an unchecked division, resulting in undefined behavior where <code>y == 0</code> or <code>x == T::MIN &amp;&amp; y == -1</code></p><p>Safe wrappers for this intrinsic are available on the integer primitives via the <code>checked_div</code> method. For example, <code>u32::checked_div</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_mul"><a href="#val-unchecked_mul" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_mul : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the result of an unchecked multiplication, resulting in undefined behavior when <code>x * y &gt; T::MAX</code> or <code>x * y &lt; T::MIN</code>.</p><p>The stable counterpart of this intrinsic is <code>unchecked_mul</code> on the various integer types, such as <code>u16::unchecked_mul</code> and <code>i64::unchecked_mul</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_rem"><a href="#val-unchecked_rem" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_rem : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the remainder of an unchecked division, resulting in undefined behavior when <code>y == 0</code> or <code>x == T::MIN &amp;&amp; y == -1</code></p><p>Safe wrappers for this intrinsic are available on the integer primitives via the <code>checked_rem</code> method. For example, <code>u32::checked_rem</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_shl"><a href="#val-unchecked_shl" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_shl : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">u</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs an unchecked left shift, resulting in undefined behavior when <code>y &lt; 0</code> or <code>y &gt;= N</code>, where N is the width of T in bits.</p><p>Safe wrappers for this intrinsic are available on the integer primitives via the <code>checked_shl</code> method. For example, <code>u32::checked_shl</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_shr"><a href="#val-unchecked_shr" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_shr : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">u</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs an unchecked right shift, resulting in undefined behavior when <code>y &lt; 0</code> or <code>y &gt;= N</code>, where N is the width of T in bits.</p><p>Safe wrappers for this intrinsic are available on the integer primitives via the <code>checked_shr</code> method. For example, <code>u32::checked_shr</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_sub"><a href="#val-unchecked_sub" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_sub : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the result of an unchecked subtraction, resulting in undefined behavior when <code>x - y &gt; T::MAX</code> or <code>x - y &lt; T::MIN</code>.</p><p>The stable counterpart of this intrinsic is <code>unchecked_sub</code> on the various integer types, such as <code>u16::unchecked_sub</code> and <code>i64::unchecked_sub</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unlikely"><a href="#val-unlikely" class="anchor"></a><code><span><span class="keyword">val</span> unlikely : <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</p><p>Any use other than with <code>if</code> statements will probably not have an effect.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unreachable"><a href="#val-unreachable" class="anchor"></a><code><span><span class="keyword">val</span> unreachable : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Informs the optimizer that this point in the code is not reachable, enabling further optimizations.</p><p>N.B., this is very different from the <code>unreachable!()</code> macro: Unlike the macro, which panics when it is executed, it is *undefined behavior* to reach code marked with this function.</p><p>The stabilized version of this intrinsic is <code>core::hint::unreachable_unchecked</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-va_arg"><a href="#val-va_arg" class="anchor"></a><code><span><span class="keyword">val</span> va_arg : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ap</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Loads an argument of type <code>T</code> from the <code>va_list</code> <code>ap</code> and increment the argument <code>ap</code> points to.</p><p>FIXME: document safety requirements</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-va_copy"><a href="#val-va_copy" class="anchor"></a><code><span><span class="keyword">val</span> va_copy : <span><span class="label">dest</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Copies the current location of arglist <code>src</code> to the arglist <code>dst</code>.</p><p>FIXME: document safety requirements</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-va_end"><a href="#val-va_end" class="anchor"></a><code><span><span class="keyword">val</span> va_end : <span><span class="label">ap</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Destroy the arglist <code>ap</code> after initialization with <code>va_start</code> or <code>va_copy</code>.</p><p>FIXME: document safety requirements</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-variant_count"><a href="#val-variant_count" class="anchor"></a><code><span><span class="keyword">val</span> variant_count : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns the number of variants of the type <code>T</code> cast to a <code>usize</code>; if <code>T</code> has no variants, returns <code>0</code>. Uninhabited variants will be counted.</p><p>Note that, unlike most intrinsics, this can only be called at compile-time as backends do not have an implementation for it. The only caller (its stable counterpart) wraps this intrinsic call in a <code>const</code> block so that backends only see an evaluated constant.</p><p>The to-be-stabilized version of this intrinsic is <code>crate::mem::variant_count</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_copy_memory"><a href="#val-volatile_copy_memory" class="anchor"></a><code><span><span class="keyword">val</span> volatile_copy_memory : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Equivalent to the appropriate <code>llvm.memmove.p0i8.0i8.*</code> intrinsic, with a size of <code>count * size_of::&lt;T&gt;()</code> and an alignment of <code>align_of::&lt;T&gt;()</code>.</p><p>The volatile parameter is set to <code>true</code>, so it will not be optimized out unless size is equal to zero.</p><p>This intrinsic does not have a stable counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_copy_nonoverlapping_memory"><a href="#val-volatile_copy_nonoverlapping_memory" class="anchor"></a><code><span><span class="keyword">val</span> volatile_copy_nonoverlapping_memory : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Equivalent to the appropriate <code>llvm.memcpy.p0i8.0i8.*</code> intrinsic, with a size of <code>count</code> * <code>size_of::&lt;T&gt;()</code> and an alignment of <code>align_of::&lt;T&gt;()</code>.</p><p>This intrinsic does not have a stable counterpart. # Safety</p><p>The safety requirements are consistent with <code>copy_nonoverlapping</code> while the read and write behaviors are volatile, which means it will not be optimized out unless <code>_count</code> or <code>size_of::&lt;T&gt;()</code> is equal to zero.</p><p><code>copy_nonoverlapping</code>: ptr::copy_nonoverlapping</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_load"><a href="#val-volatile_load" class="anchor"></a><code><span><span class="keyword">val</span> volatile_load : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs a volatile load from the <code>src</code> pointer.</p><p>The stabilized version of this intrinsic is <code>core::ptr::read_volatile</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_set_memory"><a href="#val-volatile_set_memory" class="anchor"></a><code><span><span class="keyword">val</span> volatile_set_memory : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Equivalent to the appropriate <code>llvm.memset.p0i8.*</code> intrinsic, with a size of <code>count * size_of::&lt;T&gt;()</code> and an alignment of <code>align_of::&lt;T&gt;()</code>.</p><p>This intrinsic does not have a stable counterpart. # Safety</p><p>The safety requirements are consistent with <code>write_bytes</code> while the write behavior is volatile, which means it will not be optimized out unless <code>_count</code> or <code>size_of::&lt;T&gt;()</code> is equal to zero.</p><p><code>write_bytes</code>: ptr::write_bytes</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_store"><a href="#val-volatile_store" class="anchor"></a><code><span><span class="keyword">val</span> volatile_store : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Performs a volatile store to the <code>dst</code> pointer.</p><p>The stabilized version of this intrinsic is <code>core::ptr::write_volatile</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vtable_align"><a href="#val-vtable_align" class="anchor"></a><code><span><span class="keyword">val</span> vtable_align : <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The intrinsic will return the alignment stored in that vtable.</p><p># Safety</p><p><code>ptr</code> must point to a vtable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vtable_size"><a href="#val-vtable_size" class="anchor"></a><code><span><span class="keyword">val</span> vtable_size : <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>The intrinsic will return the size stored in that vtable.</p><p># Safety</p><p><code>ptr</code> must point to a vtable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrapping_add"><a href="#val-wrapping_add" class="anchor"></a><code><span><span class="keyword">val</span> wrapping_add : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns (a + b) mod 2&lt;sup&gt;N&lt;/sup&gt;, where N is the width of T in bits.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>wrapping_add</code> method. For example, <code>u32::wrapping_add</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrapping_mul"><a href="#val-wrapping_mul" class="anchor"></a><code><span><span class="keyword">val</span> wrapping_mul : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns (a * b) mod 2&lt;sup&gt;N&lt;/sup&gt;, where N is the width of T in bits.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>wrapping_mul</code> method. For example, <code>u32::wrapping_mul</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrapping_sub"><a href="#val-wrapping_sub" class="anchor"></a><code><span><span class="keyword">val</span> wrapping_sub : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>Returns (a - b) mod 2&lt;sup&gt;N&lt;/sup&gt;, where N is the width of T in bits.</p><p>Note that, unlike most intrinsics, this is safe to call; it does not require an <code>unsafe</code> block. Therefore, implementations must not require the user to uphold any safety invariants.</p><p>The stabilized versions of this intrinsic are available on the integer primitives via the <code>wrapping_sub</code> method. For example, <code>u32::wrapping_sub</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_bytes"><a href="#val-write_bytes" class="anchor"></a><code><span><span class="keyword">val</span> write_bytes : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>This is an accidentally-stable alias to <code>ptr::write_bytes</code>; use that instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_via_move"><a href="#val-write_via_move" class="anchor"></a><code><span><span class="keyword">val</span> write_via_move : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">value</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p>This is an implementation detail of <code>crate::ptr::write</code> and should not be used anywhere else. See its comments for why this exists.</p><p>This intrinsic can *only* be called where the pointer is a local without projections (<code>write_via_move(ptr, x)</code>, not <code>write_via_move( *ptr, x)</code>) so that it trivially obeys runtime-MIR rules about derefs in operands.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_fun"><a href="#val-eval_fun" class="anchor"></a><code><span><span class="keyword">val</span> eval_fun : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-fun_exec">fun_exec</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Charon</span>.Types.generic_args <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">args</span>:<span><a href="#type-rust_val">rust_val</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div></div></div></body></html>
