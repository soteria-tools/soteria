<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>M (soteria-rust.Soteria_rust_lib.Builtins.Intrinsics.M)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../../index.html">Index</a> &#x00BB; <a href="../../../../index.html">soteria-rust</a> &#x00BB; <a href="../../../index.html">Soteria_rust_lib</a> &#x00BB; <a href="../../index.html">Builtins</a> &#x00BB; <a href="../index.html">Intrinsics</a> &#x00BB; M</nav><header class="odoc-preamble"><h1>Module <code><span>Intrinsics.M</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav></div><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-State"><a href="#argument-1-State" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-State/index.html">State</a></span><span> : <a href="../../../State_intf/module-type-S/index.html">State_intf.S</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="odoc-spec"><div class="spec type subst anchored" id="type-rust_val"><a href="#type-rust_val" class="anchor"></a><code><span><span class="keyword">type</span> rust_val</span><span> := <span><a href="argument-1-State/Sptr/index.html#type-t">State.Sptr.t</a> <a href="../../../Rust_val/index.html#type-t">Rust_val.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-ret"><a href="#type-ret" class="anchor"></a><code><span><span class="keyword">type</span> ret</span><span> :=
  <span><span>(<a href="#type-rust_val">rust_val</a> * <a href="argument-1-State/index.html#type-t">State.t</a>, <span><a href="../../../Error/index.html#type-t">Error.t</a> <a href="argument-1-State/index.html#type-err">State.err</a></span> * <a href="argument-1-State/index.html#type-t">State.t</a>, <span><a href="argument-1-State/index.html#type-serialized">State.serialized</a> list</span>)</span>
    <a href="../../../Rustsymex/SYMEX/Result/index.html#type-t">Soteria_rust_lib.Rustsymex.Result.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-fun_exec"><a href="#type-fun_exec" class="anchor"></a><code><span><span class="keyword">type</span> fun_exec</span><span> :=
  <span><span class="xref-unresolved">Charon</span>.UllbcAst.fun_decl <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">args</span>:<span><a href="#type-rust_val">rust_val</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-rust_val">rust_val</a> * <a href="argument-1-State/index.html#type-t">State.t</a>, <span><a href="../../../Error/index.html#type-t">Error.t</a> <a href="argument-1-State/index.html#type-err">State.err</a></span> * <a href="argument-1-State/index.html#type-t">State.t</a>, <span><a href="argument-1-State/index.html#type-serialized">State.serialized</a> list</span>)</span>
    <a href="../../../Rustsymex/SYMEX/Result/index.html#type-t">Soteria_rust_lib.Rustsymex.Result.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-abort"><a href="#val-abort" class="anchor"></a><code><span><span class="keyword">val</span> abort : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Aborts the execution of the process.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,
   as its behavior is more user-friendly and more stable.

   The current implementation of `intrinsics::abort` is to invoke an invalid instruction,
   on most platforms.
   On Unix, the
   process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or
   `SIGBUS`.  The precise behavior is not guaranteed and not stable.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_with_overflow"><a href="#val-add_with_overflow" class="anchor"></a><code><span><span class="keyword">val</span> add_with_overflow : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs checked integer addition.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `overflowing_add` method. For example,
   [`u32::overflowing_add`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-aggregate_raw_ptr"><a href="#val-aggregate_raw_ptr" class="anchor"></a><code><span><span class="keyword">val</span> aggregate_raw_ptr : 
  <span><span class="label">p</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">d</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">m</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">meta</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Lowers in MIR to `Rvalue::Aggregate` with `AggregateKind::RawPtr`.

   This is used to implement functions like `slice::from_raw_parts_mut` and
   `ptr::from_raw_parts` in a way compatible with the compiler being able to
   change the possible layouts of pointers.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-align_of"><a href="#val-align_of" class="anchor"></a><code><span><span class="keyword">val</span> align_of : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The minimum alignment of a type.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is [`align_of`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-align_of_val"><a href="#val-align_of_val" class="anchor"></a><code><span><span class="keyword">val</span> align_of_val : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The required alignment of the referenced value.

   The stabilized version of this intrinsic is [`align_of_val`].

   # Safety

   See [`crate::mem::align_of_val_raw`] for safety conditions.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-arith_offset"><a href="#val-arith_offset" class="anchor"></a><code><span><span class="keyword">val</span> arith_offset : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">offset</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Calculates the offset from a pointer, potentially wrapping.

   This is implemented as an intrinsic to avoid converting to and from an
   integer, since the conversion inhibits certain optimizations.

   # Safety

   Unlike the `offset` intrinsic, this intrinsic does not restrict the
   resulting pointer to point into or at the end of an allocated
   object, and it wraps with two's complement arithmetic. The resulting
   value is not necessarily valid to be used to actually access memory.

   The stabilized version of this intrinsic is [`pointer::wrapping_offset`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assert_inhabited"><a href="#val-assert_inhabited" class="anchor"></a><code><span><span class="keyword">val</span> assert_inhabited : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:
   This will statically either panic, or do nothing. It does not *guarantee* to ever panic,
   and should only be called if an assertion failure will imply language UB in the following code.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assert_mem_uninitialized_valid"><a href="#val-assert_mem_uninitialized_valid" class="anchor"></a><code><span><span class="keyword">val</span> assert_mem_uninitialized_valid : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  A guard for `std::mem::uninitialized`. This will statically either panic, or do nothing. It does
   not *guarantee* to ever panic, and should only be called if an assertion failure will imply
   language UB in the following code.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assert_zero_valid"><a href="#val-assert_zero_valid" class="anchor"></a><code><span><span class="keyword">val</span> assert_zero_valid : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  A guard for unsafe functions that cannot ever be executed if `T` does not permit
   zero-initialization: This will statically either panic, or do nothing. It does not *guarantee*
   to ever panic, and should only be called if an assertion failure will imply language UB in the
   following code.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assume"><a href="#val-assume" class="anchor"></a><code><span><span class="keyword">val</span> assume : <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Informs the optimizer that a condition is always true.
   If the condition is false, the behavior is undefined.

   No code is generated for this intrinsic, but the optimizer will try
   to preserve it (and its condition) between passes, which may interfere
   with optimization of surrounding code and reduce performance. It should
   not be used if the invariant can be discovered by the optimizer on its
   own, or if it does not enable any significant optimizations.

   The stabilized version of this intrinsic is [`core::hint::assert_unchecked`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bitreverse"><a href="#val-bitreverse" class="anchor"></a><code><span><span class="keyword">val</span> bitreverse : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Reverses the bits in an integer type `T`.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `reverse_bits` method. For example,
   [`u32::reverse_bits`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-black_box"><a href="#val-black_box" class="anchor"></a><code><span><span class="keyword">val</span> black_box : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dummy</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  See documentation of [`std::hint::black_box`] for details.

   [`std::hint::black_box`]: crate::hint::black_box</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-breakpoint"><a href="#val-breakpoint" class="anchor"></a><code><span><span class="keyword">val</span> breakpoint : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Executes a breakpoint trap, for inspection by a debugger.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bswap"><a href="#val-bswap" class="anchor"></a><code><span><span class="keyword">val</span> bswap : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Reverses the bytes in an integer type `T`.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `swap_bytes` method. For example,
   [`u32::swap_bytes`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-caller_location"><a href="#val-caller_location" class="anchor"></a><code><span><span class="keyword">val</span> caller_location : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Gets a reference to a static `Location` indicating where it was called.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   Consider using [`core::panic::Location::caller`] instead.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-carrying_mul_add"><a href="#val-carrying_mul_add" class="anchor"></a><code><span><span class="keyword">val</span> carrying_mul_add : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">u</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">multiplier</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">multiplicand</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">addend</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">carry</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs full-width multiplication and addition with a carry:
   `multiplier * multiplicand + addend + carry`.

   This is possible without any overflow.  For `uN`:
      MAX * MAX + MAX + MAX
   =&gt; (2ⁿ-1) × (2ⁿ-1) + (2ⁿ-1) + (2ⁿ-1)
   =&gt; (2²ⁿ - 2ⁿ⁺¹ + 1) + (2ⁿ⁺¹ - 2)
   =&gt; 2²ⁿ - 1

   For `iN`, the upper bound is MIN * MIN + MAX + MAX =&gt; 2²ⁿ⁻² + 2ⁿ - 2,
   and the lower bound is MAX * MIN + MIN + MIN =&gt; -2²ⁿ⁻² - 2ⁿ + 2ⁿ⁺¹.

   This currently supports unsigned integers *only*, no signed ones.
   The stabilized versions of this intrinsic are available on integers.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-catch_unwind"><a href="#val-catch_unwind" class="anchor"></a><code><span><span class="keyword">val</span> catch_unwind : 
  <span><a href="#type-fun_exec">fun_exec</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_try_fn</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_catch_fn</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Rust's &quot;try catch&quot; construct for unwinding. Invokes the function pointer `try_fn` with the
   data pointer `data`, and calls `catch_fn` if unwinding occurs while `try_fn` runs.
   Returns `1` if unwinding occurred and `catch_fn` was called; returns `0` otherwise.

   `catch_fn` must not unwind.

   The third argument is a function called if an unwind occurs (both Rust `panic` and foreign
   unwinds). This function takes the data pointer and a pointer to the target- and
   runtime-specific exception object that was caught.

   Note that in the case of a foreign unwinding operation, the exception object data may not be
   safely usable from Rust, and should not be directly exposed via the standard library. To
   prevent unsafe access, the library implementation may either abort the process or present an
   opaque error type to the user.

   For more information, see the compiler's source, as well as the documentation for the stable
   version of this intrinsic, `std::panic::catch_unwind`.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceilf128"><a href="#val-ceilf128" class="anchor"></a><code><span><span class="keyword">val</span> ceilf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the smallest integer greater than or equal to an `f128`.

   The stabilized version of this intrinsic is
   [`f128::ceil`](../../std/primitive.f128.html#method.ceil)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceilf16"><a href="#val-ceilf16" class="anchor"></a><code><span><span class="keyword">val</span> ceilf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the smallest integer greater than or equal to an `f16`.

   The stabilized version of this intrinsic is
   [`f16::ceil`](../../std/primitive.f16.html#method.ceil)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceilf32"><a href="#val-ceilf32" class="anchor"></a><code><span><span class="keyword">val</span> ceilf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the smallest integer greater than or equal to an `f32`.

   The stabilized version of this intrinsic is
   [`f32::ceil`](../../std/primitive.f32.html#method.ceil)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ceilf64"><a href="#val-ceilf64" class="anchor"></a><code><span><span class="keyword">val</span> ceilf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the smallest integer greater than or equal to an `f64`.

   The stabilized version of this intrinsic is
   [`f64::ceil`](../../std/primitive.f64.html#method.ceil)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cold_path"><a href="#val-cold_path" class="anchor"></a><code><span><span class="keyword">val</span> cold_path : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Hints to the compiler that current code path is cold.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_bytes"><a href="#val-compare_bytes" class="anchor"></a><code><span><span class="keyword">val</span> compare_bytes : 
  <span><span class="label">left</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">right</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">bytes</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Lexicographically compare `[left, left + bytes)` and `[right, right + bytes)`
   as unsigned bytes, returning negative if `left` is less, zero if all the
   bytes match, or positive if `left` is greater.

   This underlies things like `&lt;[u8]&gt;::cmp`, and will usually lower to `memcmp`.

   # Safety

   `left` and `right` must each be [valid] for reads of `bytes` bytes.

   Note that this applies to the whole range, not just until the first byte
   that differs.  That allows optimizations that can read in large chunks.

   [valid]: crate::ptr#safety</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-const_deallocate"><a href="#val-const_deallocate" class="anchor"></a><code><span><span class="keyword">val</span> const_deallocate : 
  <span><span class="label">_ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_size</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_align</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Deallocates a memory which allocated by `intrinsics::const_allocate` at compile time.
   At runtime, does nothing.

   # Safety

   - The `align` argument must be a power of two.
      - At compile time, a compile error occurs if this constraint is violated.
      - At runtime, it is not checked.
   - If the `ptr` is created in an another const, this intrinsic doesn't deallocate it.
   - If the `ptr` is pointing to a local variable, this intrinsic doesn't deallocate it.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-const_eval_select"><a href="#val-const_eval_select" class="anchor"></a><code><span><span class="keyword">val</span> const_eval_select : 
  <span><span class="label">arg</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">f</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">g</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ret</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_arg</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_called_in_const</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_called_at_rt</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Selects which function to call depending on the context.

   If this function is evaluated at compile-time, then a call to this
   intrinsic will be replaced with a call to `called_in_const`. It gets
   replaced with a call to `called_at_rt` otherwise.

   This function is safe to call, but note the stability concerns below.

   # Type Requirements

   The two functions must be both function items. They cannot be function
   pointers or closures. The first function must be a `const fn`.

   `arg` will be the tupled arguments that will be passed to either one of
   the two functions, therefore, both functions must accept the same type of
   arguments. Both functions must return RET.

   # Stability concerns

   Rust has not yet decided that `const fn` are allowed to tell whether
   they run at compile-time or at runtime. Therefore, when using this
   intrinsic anywhere that can be reached from stable, it is crucial that
   the end-to-end behavior of the stable `const fn` is the same for both
   modes of execution. (Here, Undefined Behavior is considered &quot;the same&quot;
   as any other behavior, so if the function exhibits UB at runtime then
   it may do whatever it wants at compile-time.)

   Here is an example of how this could cause a problem:
   ```no_run
   #![feature(const_eval_select)]
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]
   use std::intrinsics::const_eval_select;

   // Standard library
   pub const fn inconsistent() -&gt; i32 {
       fn runtime() -&gt; i32 { 1 }
       const fn compiletime() -&gt; i32 { 2 }

       // ⚠ This code violates the required equivalence of `compiletime`
       // and `runtime`.
       const_eval_select((), compiletime, runtime)
   }

   // User Crate
   const X: i32 = inconsistent();
   let x = inconsistent();
   assert_eq!(x, X);
   ```

   Currently such an assertion would always succeed; until Rust decides
   otherwise, that principle should not be violated.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contract_check_ensures"><a href="#val-contract_check_ensures" class="anchor"></a><code><span><span class="keyword">val</span> contract_check_ensures : 
  <span><span class="label">c</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">t_ret</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cond</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ret</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Check if the post-condition `cond` has been met.

   By default, if `contract_checks` is enabled, this will panic with no unwind if the condition
   returns false.

   Note that this function is a no-op during constant evaluation.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contract_check_requires"><a href="#val-contract_check_requires" class="anchor"></a><code><span><span class="keyword">val</span> contract_check_requires : 
  <span><span class="label">c</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">arg1</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Check if the pre-condition `cond` has been met.

   By default, if `contract_checks` is enabled, this will panic with no unwind if the condition
   returns false.

   Note that this function is a no-op during constant evaluation.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contract_checks"><a href="#val-contract_checks" class="anchor"></a><code><span><span class="keyword">val</span> contract_checks : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns whether we should perform contract-checking at runtime.

   This is meant to be similar to the ub_checks intrinsic, in terms
   of not prematurely committing at compile-time to whether contract
   checking is turned on, so that we can specify contracts in libstd
   and let an end user opt into turning them on.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  This is an accidentally-stable alias to [`ptr::copy`]; use that instead.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy_nonoverlapping"><a href="#val-copy_nonoverlapping" class="anchor"></a><code><span><span class="keyword">val</span> copy_nonoverlapping : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  This is an accidentally-stable alias to [`ptr::copy_nonoverlapping`]; use that instead.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copysignf128"><a href="#val-copysignf128" class="anchor"></a><code><span><span class="keyword">val</span> copysignf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Copies the sign from `y` to `x` for `f128` values.

   The stabilized version of this intrinsic is
   [`f128::copysign`](../../std/primitive.f128.html#method.copysign)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copysignf16"><a href="#val-copysignf16" class="anchor"></a><code><span><span class="keyword">val</span> copysignf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Copies the sign from `y` to `x` for `f16` values.

   The stabilized version of this intrinsic is
   [`f16::copysign`](../../std/primitive.f16.html#method.copysign)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copysignf32"><a href="#val-copysignf32" class="anchor"></a><code><span><span class="keyword">val</span> copysignf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Copies the sign from `y` to `x` for `f32` values.

   The stabilized version of this intrinsic is
   [`f32::copysign`](../../std/primitive.f32.html#method.copysign)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copysignf64"><a href="#val-copysignf64" class="anchor"></a><code><span><span class="keyword">val</span> copysignf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Copies the sign from `y` to `x` for `f64` values.

   The stabilized version of this intrinsic is
   [`f64::copysign`](../../std/primitive.f64.html#method.copysign)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosf128"><a href="#val-cosf128" class="anchor"></a><code><span><span class="keyword">val</span> cosf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the cosine of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::cos`](../../std/primitive.f128.html#method.cos)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosf16"><a href="#val-cosf16" class="anchor"></a><code><span><span class="keyword">val</span> cosf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the cosine of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::cos`](../../std/primitive.f16.html#method.cos)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosf32"><a href="#val-cosf32" class="anchor"></a><code><span><span class="keyword">val</span> cosf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the cosine of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::cos`](../../std/primitive.f32.html#method.cos)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosf64"><a href="#val-cosf64" class="anchor"></a><code><span><span class="keyword">val</span> cosf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the cosine of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::cos`](../../std/primitive.f64.html#method.cos)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ctlz"><a href="#val-ctlz" class="anchor"></a><code><span><span class="keyword">val</span> ctlz : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the number of leading unset bits (zeroes) in an integer type `T`.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `leading_zeros` method. For example,
   [`u32::leading_zeros`]

   # Examples

   ```
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]

   use std::intrinsics::ctlz;

   let x = 0b0001_1100_u8;
   let num_leading = ctlz(x);
   assert_eq!(num_leading, 3);
   ```

   An `x` with value `0` will return the bit width of `T`.

   ```
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]

   use std::intrinsics::ctlz;

   let x = 0u16;
   let num_leading = ctlz(x);
   assert_eq!(num_leading, 16);
   ```</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ctlz_nonzero"><a href="#val-ctlz_nonzero" class="anchor"></a><code><span><span class="keyword">val</span> ctlz_nonzero : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Like `ctlz`, but extra-unsafe as it returns `undef` when
   given an `x` with value `0`.

   This intrinsic does not have a stable counterpart.

   # Examples

   ```
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]

   use std::intrinsics::ctlz_nonzero;

   let x = 0b0001_1100_u8;
   let num_leading = unsafe { ctlz_nonzero(x) };
   assert_eq!(num_leading, 3);
   ```</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ctpop"><a href="#val-ctpop" class="anchor"></a><code><span><span class="keyword">val</span> ctpop : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the number of bits set in an integer type `T`

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `count_ones` method. For example,
   [`u32::count_ones`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cttz"><a href="#val-cttz" class="anchor"></a><code><span><span class="keyword">val</span> cttz : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the number of trailing unset bits (zeroes) in an integer type `T`.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `trailing_zeros` method. For example,
   [`u32::trailing_zeros`]

   # Examples

   ```
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]

   use std::intrinsics::cttz;

   let x = 0b0011_1000_u8;
   let num_trailing = cttz(x);
   assert_eq!(num_trailing, 3);
   ```

   An `x` with value `0` will return the bit width of `T`:

   ```
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]

   use std::intrinsics::cttz;

   let x = 0u16;
   let num_trailing = cttz(x);
   assert_eq!(num_trailing, 16);
   ```</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cttz_nonzero"><a href="#val-cttz_nonzero" class="anchor"></a><code><span><span class="keyword">val</span> cttz_nonzero : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Like `cttz`, but extra-unsafe as it returns `undef` when
   given an `x` with value `0`.

   This intrinsic does not have a stable counterpart.

   # Examples

   ```
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]

   use std::intrinsics::cttz_nonzero;

   let x = 0b0011_1000_u8;
   let num_trailing = unsafe { cttz_nonzero(x) };
   assert_eq!(num_trailing, 3);
   ```</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-discriminant_value"><a href="#val-discriminant_value" class="anchor"></a><code><span><span class="keyword">val</span> discriminant_value : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">v</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the value of the discriminant for the variant in 'v';
   if `T` has no discriminant, returns `0`.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is [`core::mem::discriminant`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-disjoint_bitor"><a href="#val-disjoint_bitor" class="anchor"></a><code><span><span class="keyword">val</span> disjoint_bitor : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Combine two values which have no bits in common.

   This allows the backend to implement it as `a + b` *or* `a | b`,
   depending which is easier to implement on a specific target.

   # Safety

   Requires that `(a &amp; b) == 0`, or equivalently that `(a | b) == (a + b)`.

   Otherwise it's immediate UB.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exact_div"><a href="#val-exact_div" class="anchor"></a><code><span><span class="keyword">val</span> exact_div : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs an exact division, resulting in undefined behavior where
   `x % y != 0` or `y == 0` or `x == T::MIN &amp;&amp; y == -1`

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp2f128"><a href="#val-exp2f128" class="anchor"></a><code><span><span class="keyword">val</span> exp2f128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns 2 raised to the power of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::exp2`](../../std/primitive.f128.html#method.exp2)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp2f16"><a href="#val-exp2f16" class="anchor"></a><code><span><span class="keyword">val</span> exp2f16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns 2 raised to the power of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::exp2`](../../std/primitive.f16.html#method.exp2)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp2f32"><a href="#val-exp2f32" class="anchor"></a><code><span><span class="keyword">val</span> exp2f32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns 2 raised to the power of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::exp2`](../../std/primitive.f32.html#method.exp2)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp2f64"><a href="#val-exp2f64" class="anchor"></a><code><span><span class="keyword">val</span> exp2f64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns 2 raised to the power of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::exp2`](../../std/primitive.f64.html#method.exp2)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expf128"><a href="#val-expf128" class="anchor"></a><code><span><span class="keyword">val</span> expf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the exponential of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::exp`](../../std/primitive.f128.html#method.exp)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expf16"><a href="#val-expf16" class="anchor"></a><code><span><span class="keyword">val</span> expf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the exponential of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::exp`](../../std/primitive.f16.html#method.exp)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expf32"><a href="#val-expf32" class="anchor"></a><code><span><span class="keyword">val</span> expf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the exponential of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::exp`](../../std/primitive.f32.html#method.exp)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expf64"><a href="#val-expf64" class="anchor"></a><code><span><span class="keyword">val</span> expf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the exponential of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::exp`](../../std/primitive.f64.html#method.exp)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fabsf128"><a href="#val-fabsf128" class="anchor"></a><code><span><span class="keyword">val</span> fabsf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the absolute value of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::abs`](../../std/primitive.f128.html#method.abs)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fabsf16"><a href="#val-fabsf16" class="anchor"></a><code><span><span class="keyword">val</span> fabsf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the absolute value of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::abs`](../../std/primitive.f16.html#method.abs)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fabsf32"><a href="#val-fabsf32" class="anchor"></a><code><span><span class="keyword">val</span> fabsf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the absolute value of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::abs`](../../std/primitive.f32.html#method.abs)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fabsf64"><a href="#val-fabsf64" class="anchor"></a><code><span><span class="keyword">val</span> fabsf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the absolute value of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::abs`](../../std/primitive.f64.html#method.abs)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fadd_algebraic"><a href="#val-fadd_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> fadd_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float addition that allows optimizations based on algebraic rules.

   Stabilized as [`f16::algebraic_add`], [`f32::algebraic_add`], [`f64::algebraic_add`] and [`f128::algebraic_add`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fadd_fast"><a href="#val-fadd_fast" class="anchor"></a><code><span><span class="keyword">val</span> fadd_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float addition that allows optimizations based on algebraic rules.
   May assume inputs are finite.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fdiv_algebraic"><a href="#val-fdiv_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> fdiv_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float division that allows optimizations based on algebraic rules.

   Stabilized as [`f16::algebraic_div`], [`f32::algebraic_div`], [`f64::algebraic_div`] and [`f128::algebraic_div`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fdiv_fast"><a href="#val-fdiv_fast" class="anchor"></a><code><span><span class="keyword">val</span> fdiv_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float division that allows optimizations based on algebraic rules.
   May assume inputs are finite.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float_to_int_unchecked"><a href="#val-float_to_int_unchecked" class="anchor"></a><code><span><span class="keyword">val</span> float_to_int_unchecked : 
  <span><span class="label">float</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">int</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">value</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Converts with LLVM’s fptoui/fptosi, which may return undef for values out of range
   (&lt;https://github.com/rust-lang/rust/issues/10184&gt;)

   Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floorf128"><a href="#val-floorf128" class="anchor"></a><code><span><span class="keyword">val</span> floorf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the largest integer less than or equal to an `f128`.

   The stabilized version of this intrinsic is
   [`f128::floor`](../../std/primitive.f128.html#method.floor)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floorf16"><a href="#val-floorf16" class="anchor"></a><code><span><span class="keyword">val</span> floorf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the largest integer less than or equal to an `f16`.

   The stabilized version of this intrinsic is
   [`f16::floor`](../../std/primitive.f16.html#method.floor)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floorf32"><a href="#val-floorf32" class="anchor"></a><code><span><span class="keyword">val</span> floorf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the largest integer less than or equal to an `f32`.

   The stabilized version of this intrinsic is
   [`f32::floor`](../../std/primitive.f32.html#method.floor)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floorf64"><a href="#val-floorf64" class="anchor"></a><code><span><span class="keyword">val</span> floorf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the largest integer less than or equal to an `f64`.

   The stabilized version of this intrinsic is
   [`f64::floor`](../../std/primitive.f64.html#method.floor)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmaf128"><a href="#val-fmaf128" class="anchor"></a><code><span><span class="keyword">val</span> fmaf128 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `a * b + c` for `f128` values.

   The stabilized version of this intrinsic is
   [`f128::mul_add`](../../std/primitive.f128.html#method.mul_add)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmaf16"><a href="#val-fmaf16" class="anchor"></a><code><span><span class="keyword">val</span> fmaf16 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `a * b + c` for `f16` values.

   The stabilized version of this intrinsic is
   [`f16::mul_add`](../../std/primitive.f16.html#method.mul_add)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmaf32"><a href="#val-fmaf32" class="anchor"></a><code><span><span class="keyword">val</span> fmaf32 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `a * b + c` for `f32` values.

   The stabilized version of this intrinsic is
   [`f32::mul_add`](../../std/primitive.f32.html#method.mul_add)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmaf64"><a href="#val-fmaf64" class="anchor"></a><code><span><span class="keyword">val</span> fmaf64 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `a * b + c` for `f64` values.

   The stabilized version of this intrinsic is
   [`f64::mul_add`](../../std/primitive.f64.html#method.mul_add)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmul_algebraic"><a href="#val-fmul_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> fmul_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float multiplication that allows optimizations based on algebraic rules.

   Stabilized as [`f16::algebraic_mul`], [`f32::algebraic_mul`], [`f64::algebraic_mul`] and [`f128::algebraic_mul`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmul_fast"><a href="#val-fmul_fast" class="anchor"></a><code><span><span class="keyword">val</span> fmul_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float multiplication that allows optimizations based on algebraic rules.
   May assume inputs are finite.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmuladdf128"><a href="#val-fmuladdf128" class="anchor"></a><code><span><span class="keyword">val</span> fmuladdf128 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `a * b + c` for `f128` values, non-deterministically executing
   either a fused multiply-add or two operations with rounding of the
   intermediate result.

   The operation is fused if the code generator determines that target
   instruction set has support for a fused operation, and that the fused
   operation is more efficient than the equivalent, separate pair of mul
   and add instructions. It is unspecified whether or not a fused operation
   is selected, and that may depend on optimization level and context, for
   example.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmuladdf16"><a href="#val-fmuladdf16" class="anchor"></a><code><span><span class="keyword">val</span> fmuladdf16 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `a * b + c` for `f16` values, non-deterministically executing
   either a fused multiply-add or two operations with rounding of the
   intermediate result.

   The operation is fused if the code generator determines that target
   instruction set has support for a fused operation, and that the fused
   operation is more efficient than the equivalent, separate pair of mul
   and add instructions. It is unspecified whether or not a fused operation
   is selected, and that may depend on optimization level and context, for
   example.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmuladdf32"><a href="#val-fmuladdf32" class="anchor"></a><code><span><span class="keyword">val</span> fmuladdf32 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `a * b + c` for `f32` values, non-deterministically executing
   either a fused multiply-add or two operations with rounding of the
   intermediate result.

   The operation is fused if the code generator determines that target
   instruction set has support for a fused operation, and that the fused
   operation is more efficient than the equivalent, separate pair of mul
   and add instructions. It is unspecified whether or not a fused operation
   is selected, and that may depend on optimization level and context, for
   example.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmuladdf64"><a href="#val-fmuladdf64" class="anchor"></a><code><span><span class="keyword">val</span> fmuladdf64 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">c</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `a * b + c` for `f64` values, non-deterministically executing
   either a fused multiply-add or two operations with rounding of the
   intermediate result.

   The operation is fused if the code generator determines that target
   instruction set has support for a fused operation, and that the fused
   operation is more efficient than the equivalent, separate pair of mul
   and add instructions. It is unspecified whether or not a fused operation
   is selected, and that may depend on optimization level and context, for
   example.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-forget"><a href="#val-forget" class="anchor"></a><code><span><span class="keyword">val</span> forget : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">arg</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Moves a value out of scope without running drop glue.

   This exists solely for [`crate::mem::forget_unsized`]; normal `forget` uses
   `ManuallyDrop` instead.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-frem_algebraic"><a href="#val-frem_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> frem_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float remainder that allows optimizations based on algebraic rules.

   Stabilized as [`f16::algebraic_rem`], [`f32::algebraic_rem`], [`f64::algebraic_rem`] and [`f128::algebraic_rem`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-frem_fast"><a href="#val-frem_fast" class="anchor"></a><code><span><span class="keyword">val</span> frem_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float remainder that allows optimizations based on algebraic rules.
   May assume inputs are finite.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fsub_algebraic"><a href="#val-fsub_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> fsub_algebraic : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float subtraction that allows optimizations based on algebraic rules.

   Stabilized as [`f16::algebraic_sub`], [`f32::algebraic_sub`], [`f64::algebraic_sub`] and [`f128::algebraic_sub`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fsub_fast"><a href="#val-fsub_fast" class="anchor"></a><code><span><span class="keyword">val</span> fsub_fast : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Float subtraction that allows optimizations based on algebraic rules.
   May assume inputs are finite.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_val_statically_known"><a href="#val-is_val_statically_known" class="anchor"></a><code><span><span class="keyword">val</span> is_val_statically_known : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">_arg</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns whether the argument's value is statically known at
   compile-time.

   This is useful when there is a way of writing the code that will
   be *faster* when some variables have known values, but *slower*
   in the general case: an `if is_val_statically_known(var)` can be used
   to select between these two variants. The `if` will be optimized away
   and only the desired branch remains.

   Formally speaking, this function non-deterministically returns `true`
   or `false`, and the caller has to ensure sound behavior for both cases.
   In other words, the following code has *Undefined Behavior*:

   ```no_run
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]
   use std::hint::unreachable_unchecked;
   use std::intrinsics::is_val_statically_known;

   if !is_val_statically_known(0) { unsafe { unreachable_unchecked(); } }
   ```

   This also means that the following code's behavior is unspecified; it
   may panic, or it may not:

   ```no_run
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]
   use std::intrinsics::is_val_statically_known;

   assert_eq!(is_val_statically_known(0), is_val_statically_known(0));
   ```

   Unsafe code may not rely on `is_val_statically_known` returning any
   particular value, ever. However, the compiler will generally make it
   return `true` only if the value of the argument is actually known.

   # Stability concerns

   While it is safe to call, this intrinsic may behave differently in
   a `const` context than otherwise. See the [`const_eval_select()`]
   documentation for an explanation of the issues this can cause. Unlike
   `const_eval_select`, this intrinsic isn't guaranteed to behave
   deterministically even in a `const` context.

   # Type Requirements

   `T` must be either a `bool`, a `char`, a primitive numeric type (e.g. `f32`,
   but not `NonZeroISize`), or any thin pointer (e.g. `*mut String`).
   Any other argument types *may* cause a compiler error.

   ## Pointers

   When the input is a pointer, only the pointer itself is
   ever considered. The pointee has no effect. Currently, these functions
   behave identically:

   ```
   #![feature(core_intrinsics)]
   # #![allow(internal_features)]
   use std::intrinsics::is_val_statically_known;

   fn foo(x: &amp;i32) -&gt; bool {
       is_val_statically_known(x)
   }

   fn bar(x: &amp;i32) -&gt; bool {
       is_val_statically_known(
           (x as *const i32).addr()
       )
   }
   # _ = foo(&amp;5_i32);
   # _ = bar(&amp;5_i32);
   ```</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-likely"><a href="#val-likely" class="anchor"></a><code><span><span class="keyword">val</span> likely : <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Hints to the compiler that branch condition is likely to be true.
   Returns the value passed to it.

   Any use other than with `if` statements will probably not have an effect.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log10f128"><a href="#val-log10f128" class="anchor"></a><code><span><span class="keyword">val</span> log10f128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the base 10 logarithm of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::log10`](../../std/primitive.f128.html#method.log10)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log10f16"><a href="#val-log10f16" class="anchor"></a><code><span><span class="keyword">val</span> log10f16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the base 10 logarithm of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::log10`](../../std/primitive.f16.html#method.log10)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log10f32"><a href="#val-log10f32" class="anchor"></a><code><span><span class="keyword">val</span> log10f32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the base 10 logarithm of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::log10`](../../std/primitive.f32.html#method.log10)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log10f64"><a href="#val-log10f64" class="anchor"></a><code><span><span class="keyword">val</span> log10f64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the base 10 logarithm of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::log10`](../../std/primitive.f64.html#method.log10)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log2f128"><a href="#val-log2f128" class="anchor"></a><code><span><span class="keyword">val</span> log2f128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the base 2 logarithm of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::log2`](../../std/primitive.f128.html#method.log2)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log2f16"><a href="#val-log2f16" class="anchor"></a><code><span><span class="keyword">val</span> log2f16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the base 2 logarithm of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::log2`](../../std/primitive.f16.html#method.log2)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log2f32"><a href="#val-log2f32" class="anchor"></a><code><span><span class="keyword">val</span> log2f32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the base 2 logarithm of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::log2`](../../std/primitive.f32.html#method.log2)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log2f64"><a href="#val-log2f64" class="anchor"></a><code><span><span class="keyword">val</span> log2f64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the base 2 logarithm of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::log2`](../../std/primitive.f64.html#method.log2)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logf128"><a href="#val-logf128" class="anchor"></a><code><span><span class="keyword">val</span> logf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the natural logarithm of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::ln`](../../std/primitive.f128.html#method.ln)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logf16"><a href="#val-logf16" class="anchor"></a><code><span><span class="keyword">val</span> logf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the natural logarithm of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::ln`](../../std/primitive.f16.html#method.ln)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logf32"><a href="#val-logf32" class="anchor"></a><code><span><span class="keyword">val</span> logf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the natural logarithm of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::ln`](../../std/primitive.f32.html#method.ln)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logf64"><a href="#val-logf64" class="anchor"></a><code><span><span class="keyword">val</span> logf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the natural logarithm of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::ln`](../../std/primitive.f64.html#method.ln)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximumf128"><a href="#val-maximumf128" class="anchor"></a><code><span><span class="keyword">val</span> maximumf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the maximum (IEEE 754-2019 maximum) of two `f128` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximumf16"><a href="#val-maximumf16" class="anchor"></a><code><span><span class="keyword">val</span> maximumf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the maximum (IEEE 754-2019 maximum) of two `f16` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximumf32"><a href="#val-maximumf32" class="anchor"></a><code><span><span class="keyword">val</span> maximumf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the maximum (IEEE 754-2019 maximum) of two `f32` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximumf64"><a href="#val-maximumf64" class="anchor"></a><code><span><span class="keyword">val</span> maximumf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the maximum (IEEE 754-2019 maximum) of two `f64` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maxnumf128"><a href="#val-maxnumf128" class="anchor"></a><code><span><span class="keyword">val</span> maxnumf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the maximum (IEEE 754-2008 maxNum) of two `f128` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is
   [`f128::max`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maxnumf16"><a href="#val-maxnumf16" class="anchor"></a><code><span><span class="keyword">val</span> maxnumf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the maximum (IEEE 754-2008 maxNum) of two `f16` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is
   [`f16::max`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maxnumf32"><a href="#val-maxnumf32" class="anchor"></a><code><span><span class="keyword">val</span> maxnumf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the maximum (IEEE 754-2008 maxNum) of two `f32` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is
   [`f32::max`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maxnumf64"><a href="#val-maxnumf64" class="anchor"></a><code><span><span class="keyword">val</span> maxnumf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the maximum (IEEE 754-2008 maxNum) of two `f64` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is
   [`f64::max`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minimumf128"><a href="#val-minimumf128" class="anchor"></a><code><span><span class="keyword">val</span> minimumf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the minimum (IEEE 754-2019 minimum) of two `f128` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minimumf16"><a href="#val-minimumf16" class="anchor"></a><code><span><span class="keyword">val</span> minimumf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the minimum (IEEE 754-2019 minimum) of two `f16` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minimumf32"><a href="#val-minimumf32" class="anchor"></a><code><span><span class="keyword">val</span> minimumf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the minimum (IEEE 754-2019 minimum) of two `f32` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minimumf64"><a href="#val-minimumf64" class="anchor"></a><code><span><span class="keyword">val</span> minimumf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the minimum (IEEE 754-2019 minimum) of two `f64` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minnumf128"><a href="#val-minnumf128" class="anchor"></a><code><span><span class="keyword">val</span> minnumf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the minimum (IEEE 754-2008 minNum) of two `f128` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is
   [`f128::min`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minnumf16"><a href="#val-minnumf16" class="anchor"></a><code><span><span class="keyword">val</span> minnumf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the minimum (IEEE 754-2008 minNum) of two `f16` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is
   [`f16::min`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minnumf32"><a href="#val-minnumf32" class="anchor"></a><code><span><span class="keyword">val</span> minnumf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the minimum (IEEE 754-2008 minNum) of two `f32` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is
   [`f32::min`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minnumf64"><a href="#val-minnumf64" class="anchor"></a><code><span><span class="keyword">val</span> minnumf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the minimum (IEEE 754-2008 minNum) of two `f64` values.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized version of this intrinsic is
   [`f64::min`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_with_overflow"><a href="#val-mul_with_overflow" class="anchor"></a><code><span><span class="keyword">val</span> mul_with_overflow : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs checked integer multiplication

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `overflowing_mul` method. For example,
   [`u32::overflowing_mul`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-needs_drop"><a href="#val-needs_drop" class="anchor"></a><code><span><span class="keyword">val</span> needs_drop : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns `true` if the actual type given as `T` requires drop
   glue; returns `false` if the actual type provided for `T`
   implements `Copy`.

   If the actual type neither requires drop glue nor implements
   `Copy`, then the return value of this function is unspecified.

   Note that, unlike most intrinsics, this can only be called at compile-time
   as backends do not have an implementation for it. The only caller (its
   stable counterpart) wraps this intrinsic call in a `const` block so that
   backends only see an evaluated constant.

   The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nontemporal_store"><a href="#val-nontemporal_store" class="anchor"></a><code><span><span class="keyword">val</span> nontemporal_store : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Emits a `nontemporal` store, which gives a hint to the CPU that the data should not be held
   in cache. Except for performance, this is fully equivalent to `ptr.write(val)`.

   Not all architectures provide such an operation. For instance, x86 does not: while `MOVNT`
   exists, that operation is *not* equivalent to `ptr.write(val)` (`MOVNT` writes can be reordered
   in ways that are not allowed for regular writes).</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-offset"><a href="#val-offset" class="anchor"></a><code><span><span class="keyword">val</span> offset : 
  <span><span class="label">ptr</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">delta</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">offset</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Calculates the offset from a pointer.

   This is implemented as an intrinsic to avoid converting to and from an
   integer, since the conversion would throw away aliasing information.

   This can only be used with `Ptr` as a raw pointer type (`*mut` or `*const`)
   to a `Sized` pointee and with `Delta` as `usize` or `isize`.  Any other
   instantiations may arbitrarily misbehave, and that's *not* a compiler bug.

   # Safety

   If the computed offset is non-zero, then both the starting and resulting pointer must be
   either in bounds or at the end of an allocation. If either pointer is out
   of bounds or arithmetic overflow occurs then this operation is undefined behavior.

   The stabilized version of this intrinsic is [`pointer::offset`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powf128"><a href="#val-powf128" class="anchor"></a><code><span><span class="keyword">val</span> powf128 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Raises an `f128` to an `f128` power.

   The stabilized version of this intrinsic is
   [`f128::powf`](../../std/primitive.f128.html#method.powf)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powf16"><a href="#val-powf16" class="anchor"></a><code><span><span class="keyword">val</span> powf16 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Raises an `f16` to an `f16` power.

   The stabilized version of this intrinsic is
   [`f16::powf`](../../std/primitive.f16.html#method.powf)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powf32"><a href="#val-powf32" class="anchor"></a><code><span><span class="keyword">val</span> powf32 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Raises an `f32` to an `f32` power.

   The stabilized version of this intrinsic is
   [`f32::powf`](../../std/primitive.f32.html#method.powf)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powf64"><a href="#val-powf64" class="anchor"></a><code><span><span class="keyword">val</span> powf64 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Raises an `f64` to an `f64` power.

   The stabilized version of this intrinsic is
   [`f64::powf`](../../std/primitive.f64.html#method.powf)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powif128"><a href="#val-powif128" class="anchor"></a><code><span><span class="keyword">val</span> powif128 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Raises an `f128` to an integer power.

   The stabilized version of this intrinsic is
   [`f128::powi`](../../std/primitive.f128.html#method.powi)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powif16"><a href="#val-powif16" class="anchor"></a><code><span><span class="keyword">val</span> powif16 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Raises an `f16` to an integer power.

   The stabilized version of this intrinsic is
   [`f16::powi`](../../std/primitive.f16.html#method.powi)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powif32"><a href="#val-powif32" class="anchor"></a><code><span><span class="keyword">val</span> powif32 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Raises an `f32` to an integer power.

   The stabilized version of this intrinsic is
   [`f32::powi`](../../std/primitive.f32.html#method.powi)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powif64"><a href="#val-powif64" class="anchor"></a><code><span><span class="keyword">val</span> powif64 : <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Raises an `f64` to an integer power.

   The stabilized version of this intrinsic is
   [`f64::powi`](../../std/primitive.f64.html#method.powi)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefetch_read_data"><a href="#val-prefetch_read_data" class="anchor"></a><code><span><span class="keyword">val</span> prefetch_read_data : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">locality</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction
   if supported; otherwise, it is a no-op.
   Prefetches have no effect on the behavior of the program but can change its performance
   characteristics.

   The `locality` argument must be a constant integer and is a temporal locality specifier
   ranging from (0) - no locality, to (3) - extremely local keep in cache.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefetch_read_instruction"><a href="#val-prefetch_read_instruction" class="anchor"></a><code><span><span class="keyword">val</span> prefetch_read_instruction : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">locality</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction
   if supported; otherwise, it is a no-op.
   Prefetches have no effect on the behavior of the program but can change its performance
   characteristics.

   The `locality` argument must be a constant integer and is a temporal locality specifier
   ranging from (0) - no locality, to (3) - extremely local keep in cache.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefetch_write_data"><a href="#val-prefetch_write_data" class="anchor"></a><code><span><span class="keyword">val</span> prefetch_write_data : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">locality</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction
   if supported; otherwise, it is a no-op.
   Prefetches have no effect on the behavior of the program but can change its performance
   characteristics.

   The `locality` argument must be a constant integer and is a temporal locality specifier
   ranging from (0) - no locality, to (3) - extremely local keep in cache.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefetch_write_instruction"><a href="#val-prefetch_write_instruction" class="anchor"></a><code><span><span class="keyword">val</span> prefetch_write_instruction : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">data</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">locality</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction
   if supported; otherwise, it is a no-op.
   Prefetches have no effect on the behavior of the program but can change its performance
   characteristics.

   The `locality` argument must be a constant integer and is a temporal locality specifier
   ranging from (0) - no locality, to (3) - extremely local keep in cache.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_guaranteed_cmp"><a href="#val-ptr_guaranteed_cmp" class="anchor"></a><code><span><span class="keyword">val</span> ptr_guaranteed_cmp : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">other</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  See documentation of `&lt;*const T&gt;::guaranteed_eq` for details.
   Returns `2` if the result is unknown.
   Returns `1` if the pointers are guaranteed equal.
   Returns `0` if the pointers are guaranteed inequal.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_mask"><a href="#val-ptr_mask" class="anchor"></a><code><span><span class="keyword">val</span> ptr_mask : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">mask</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Masks out bits of the pointer according to a mask.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   Consider using [`pointer::mask`] instead.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_metadata"><a href="#val-ptr_metadata" class="anchor"></a><code><span><span class="keyword">val</span> ptr_metadata : 
  <span><span class="label">p</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">m</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Lowers in MIR to `Rvalue::UnaryOp` with `UnOp::PtrMetadata`.

   This is used to implement functions like `ptr::metadata`.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_offset_from"><a href="#val-ptr_offset_from" class="anchor"></a><code><span><span class="keyword">val</span> ptr_offset_from : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">base</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  See documentation of `&lt;*const T&gt;::offset_from` for details.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_offset_from_unsigned"><a href="#val-ptr_offset_from_unsigned" class="anchor"></a><code><span><span class="keyword">val</span> ptr_offset_from_unsigned : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">base</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  See documentation of `&lt;*const T&gt;::offset_from_unsigned` for details.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-raw_eq"><a href="#val-raw_eq" class="anchor"></a><code><span><span class="keyword">val</span> raw_eq : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Determines whether the raw bytes of the two values are equal.

   This is particularly handy for arrays, since it allows things like just
   comparing `i96`s instead of forcing `alloca`s for `[6 x i16]`.

   Above some backend-decided threshold this will emit calls to `memcmp`,
   like slice equality does, instead of causing massive code size.

   Since this works by comparing the underlying bytes, the actual `T` is
   not particularly important.  It will be used for its size and alignment,
   but any validity restrictions will be ignored, not enforced.

   # Safety

   It's UB to call this if any of the *bytes* in `*a` or `*b` are uninitialized.
   Note that this is a stricter criterion than just the *values* being
   fully-initialized: if `T` has padding, it's UB to call this intrinsic.

   At compile-time, it is furthermore UB to call this if any of the bytes
   in `*a` or `*b` have provenance.

   (The implementation is allowed to branch on the results of comparisons,
   which is UB if any of their inputs are `undef`.)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_via_copy"><a href="#val-read_via_copy" class="anchor"></a><code><span><span class="keyword">val</span> read_via_copy : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  This is an implementation detail of [`crate::ptr::read`] and should
   not be used anywhere else.  See its comments for why this exists.

   This intrinsic can *only* be called where the pointer is a local without
   projections (`read_via_copy(ptr)`, not `read_via_copy( *ptr)`) so that it
   trivially obeys runtime-MIR rules about derefs in operands.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rotate_left"><a href="#val-rotate_left" class="anchor"></a><code><span><span class="keyword">val</span> rotate_left : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">shift</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs rotate left.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `rotate_left` method. For example,
   [`u32::rotate_left`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rotate_right"><a href="#val-rotate_right" class="anchor"></a><code><span><span class="keyword">val</span> rotate_right : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">shift</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs rotate right.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `rotate_right` method. For example,
   [`u32::rotate_right`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-round_ties_even_f128"><a href="#val-round_ties_even_f128" class="anchor"></a><code><span><span class="keyword">val</span> round_ties_even_f128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the nearest integer to an `f128`. Rounds half-way cases to the number with an even
   least significant digit.

   The stabilized version of this intrinsic is
   [`f128::round_ties_even`](../../std/primitive.f128.html#method.round_ties_even)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-round_ties_even_f16"><a href="#val-round_ties_even_f16" class="anchor"></a><code><span><span class="keyword">val</span> round_ties_even_f16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the nearest integer to an `f16`. Rounds half-way cases to the number with an even
   least significant digit.

   The stabilized version of this intrinsic is
   [`f16::round_ties_even`](../../std/primitive.f16.html#method.round_ties_even)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-round_ties_even_f32"><a href="#val-round_ties_even_f32" class="anchor"></a><code><span><span class="keyword">val</span> round_ties_even_f32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the nearest integer to an `f32`. Rounds half-way cases to the number with an even
   least significant digit.

   The stabilized version of this intrinsic is
   [`f32::round_ties_even`](../../std/primitive.f32.html#method.round_ties_even)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-round_ties_even_f64"><a href="#val-round_ties_even_f64" class="anchor"></a><code><span><span class="keyword">val</span> round_ties_even_f64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the nearest integer to an `f64`. Rounds half-way cases to the number with an even
   least significant digit.

   The stabilized version of this intrinsic is
   [`f64::round_ties_even`](../../std/primitive.f64.html#method.round_ties_even)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundf128"><a href="#val-roundf128" class="anchor"></a><code><span><span class="keyword">val</span> roundf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the nearest integer to an `f128`. Rounds half-way cases away from zero.

   The stabilized version of this intrinsic is
   [`f128::round`](../../std/primitive.f128.html#method.round)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundf16"><a href="#val-roundf16" class="anchor"></a><code><span><span class="keyword">val</span> roundf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the nearest integer to an `f16`. Rounds half-way cases away from zero.

   The stabilized version of this intrinsic is
   [`f16::round`](../../std/primitive.f16.html#method.round)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundf32"><a href="#val-roundf32" class="anchor"></a><code><span><span class="keyword">val</span> roundf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.

   The stabilized version of this intrinsic is
   [`f32::round`](../../std/primitive.f32.html#method.round)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundf64"><a href="#val-roundf64" class="anchor"></a><code><span><span class="keyword">val</span> roundf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.

   The stabilized version of this intrinsic is
   [`f64::round`](../../std/primitive.f64.html#method.round)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rustc_peek"><a href="#val-rustc_peek" class="anchor"></a><code><span><span class="keyword">val</span> rustc_peek : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">arg</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Magic intrinsic that derives its meaning from attributes
   attached to the function.

   For example, dataflow uses this to inject static assertions so
   that `rustc_peek(potentially_uninitialized)` would actually
   double-check that dataflow did indeed compute that it is
   uninitialized at that point in the control flow.

   This intrinsic should not be used outside of the compiler.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-saturating_add"><a href="#val-saturating_add" class="anchor"></a><code><span><span class="keyword">val</span> saturating_add : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Computes `a + b`, saturating at numeric bounds.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `saturating_add` method. For example,
   [`u32::saturating_add`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-saturating_sub"><a href="#val-saturating_sub" class="anchor"></a><code><span><span class="keyword">val</span> saturating_sub : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Computes `a - b`, saturating at numeric bounds.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `saturating_sub` method. For example,
   [`u32::saturating_sub`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-select_unpredictable"><a href="#val-select_unpredictable" class="anchor"></a><code><span><span class="keyword">val</span> select_unpredictable : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">true_val</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">false_val</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns either `true_val` or `false_val` depending on condition `b` with a
   hint to the compiler that this condition is unlikely to be correctly
   predicted by a CPU's branch predictor (e.g. a binary search).

   This is otherwise functionally equivalent to `if b { true_val } else { false_val }`.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The public form of this intrinsic is [`core::hint::select_unpredictable`].
   However unlike the public form, the intrinsic will not drop the value that
   is not selected.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinf128"><a href="#val-sinf128" class="anchor"></a><code><span><span class="keyword">val</span> sinf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the sine of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::sin`](../../std/primitive.f128.html#method.sin)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinf16"><a href="#val-sinf16" class="anchor"></a><code><span><span class="keyword">val</span> sinf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the sine of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::sin`](../../std/primitive.f16.html#method.sin)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinf32"><a href="#val-sinf32" class="anchor"></a><code><span><span class="keyword">val</span> sinf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the sine of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::sin`](../../std/primitive.f32.html#method.sin)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinf64"><a href="#val-sinf64" class="anchor"></a><code><span><span class="keyword">val</span> sinf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the sine of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::sin`](../../std/primitive.f64.html#method.sin)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_of"><a href="#val-size_of" class="anchor"></a><code><span><span class="keyword">val</span> size_of : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The size of a type in bytes.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   More specifically, this is the offset in bytes between successive
   items of the same type, including alignment padding.

   The stabilized version of this intrinsic is [`size_of`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_of_val"><a href="#val-size_of_val" class="anchor"></a><code><span><span class="keyword">val</span> size_of_val : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The size of the referenced value in bytes.

   The stabilized version of this intrinsic is [`size_of_val`].

   # Safety

   See [`crate::mem::size_of_val_raw`] for safety conditions.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slice_get_unchecked"><a href="#val-slice_get_unchecked" class="anchor"></a><code><span><span class="keyword">val</span> slice_get_unchecked : 
  <span><span class="label">itemptr</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sliceptr</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">slice_ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">index</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Projects to the `index`-th element of `slice_ptr`, as the same kind of pointer
   as the slice was provided -- so `&amp;mut [T] → &amp;mut T`, `&amp;[T] → &amp;T`,
   `*mut [T] → *mut T`, or `*const [T] → *const T` -- without a bounds check.

   This is exposed via `&lt;usize as SliceIndex&gt;::get(_unchecked)(_mut)`,
   and isn't intended to be used elsewhere.

   Expands in MIR to `{&amp;, &amp;mut, &amp;raw const, &amp;raw mut} ( *slice_ptr)[index]`,
   depending on the types involved, so no backend support is needed.

   # Safety

   - `index &lt; PtrMetadata(slice_ptr)`, so the indexing is in-bounds for the slice
   - the resulting offsetting is in-bounds of the allocated object, which is
     always the case for references, but needs to be upheld manually for pointers</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrtf128"><a href="#val-sqrtf128" class="anchor"></a><code><span><span class="keyword">val</span> sqrtf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the square root of an `f128`

   The stabilized version of this intrinsic is
   [`f128::sqrt`](../../std/primitive.f128.html#method.sqrt)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrtf16"><a href="#val-sqrtf16" class="anchor"></a><code><span><span class="keyword">val</span> sqrtf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the square root of an `f16`

   The stabilized version of this intrinsic is
   [`f16::sqrt`](../../std/primitive.f16.html#method.sqrt)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrtf32"><a href="#val-sqrtf32" class="anchor"></a><code><span><span class="keyword">val</span> sqrtf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the square root of an `f32`

   The stabilized version of this intrinsic is
   [`f32::sqrt`](../../std/primitive.f32.html#method.sqrt)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sqrtf64"><a href="#val-sqrtf64" class="anchor"></a><code><span><span class="keyword">val</span> sqrtf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the square root of an `f64`

   The stabilized version of this intrinsic is
   [`f64::sqrt`](../../std/primitive.f64.html#method.sqrt)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub_with_overflow"><a href="#val-sub_with_overflow" class="anchor"></a><code><span><span class="keyword">val</span> sub_with_overflow : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs checked integer subtraction

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `overflowing_sub` method. For example,
   [`u32::overflowing_sub`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-three_way_compare"><a href="#val-three_way_compare" class="anchor"></a><code><span><span class="keyword">val</span> three_way_compare : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">lhs</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">rhss</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Does a three-way comparison between the two arguments,
   which must be of character or integer (signed or unsigned) type.

   This was originally added because it greatly simplified the MIR in `cmp`
   implementations, and then LLVM 20 added a backend intrinsic for it too.

   The stabilized version of this intrinsic is [`Ord::cmp`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-transmute"><a href="#val-transmute" class="anchor"></a><code><span><span class="keyword">val</span> transmute : 
  <span><span class="label">t_src</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Reinterprets the bits of a value of one type as another type.

   Both types must have the same size. Compilation will fail if this is not guaranteed.

   `transmute` is semantically equivalent to a bitwise move of one type
   into another. It copies the bits from the source value into the
   destination value, then forgets the original. Note that source and destination
   are passed by-value, which means if `Src` or `Dst` contain padding, that padding
   is *not* guaranteed to be preserved by `transmute`.

   Both the argument and the result must be [valid](../../nomicon/what-unsafe-does.html) at
   their given type. Violating this condition leads to [undefined behavior][ub]. The compiler
   will generate code *assuming that you, the programmer, ensure that there will never be
   undefined behavior*. It is therefore your responsibility to guarantee that every value
   passed to `transmute` is valid at both types `Src` and `Dst`. Failing to uphold this condition
   may lead to unexpected and unstable compilation results. This makes `transmute` **incredibly
   unsafe**. `transmute` should be the absolute last resort.

   Because `transmute` is a by-value operation, alignment of the *transmuted values
   themselves* is not a concern. As with any other function, the compiler already ensures
   both `Src` and `Dst` are properly aligned. However, when transmuting values that *point
   elsewhere* (such as pointers, references, boxes…), the caller has to ensure proper
   alignment of the pointed-to values.

   The [nomicon](../../nomicon/transmutes.html) has additional documentation.

   [ub]: ../../reference/behavior-considered-undefined.html

   # Transmutation between pointers and integers

   Special care has to be taken when transmuting between pointers and integers, e.g.
   transmuting between `*const ()` and `usize`.

   Transmuting *pointers to integers* in a `const` context is [undefined behavior][ub], unless
   the pointer was originally created *from* an integer. (That includes this function
   specifically, integer-to-pointer casts, and helpers like [`dangling`][crate::ptr::dangling],
   but also semantically-equivalent conversions such as punning through `repr(C)` union
   fields.) Any attempt to use the resulting value for integer operations will abort
   const-evaluation. (And even outside `const`, such transmutation is touching on many
   unspecified aspects of the Rust memory model and should be avoided. See below for
   alternatives.)

   Transmuting *integers to pointers* is a largely unspecified operation. It is likely *not*
   equivalent to an `as` cast. Doing non-zero-sized memory accesses with a pointer constructed
   this way is currently considered undefined behavior.

   All this also applies when the integer is nested inside an array, tuple, struct, or enum.
   However, `MaybeUninit&lt;usize&gt;` is not considered an integer type for the purpose of this
   section. Transmuting `*const ()` to `MaybeUninit&lt;usize&gt;` is fine---but then calling
   `assume_init()` on that result is considered as completing the pointer-to-integer transmute
   and thus runs into the issues discussed above.

   In particular, doing a pointer-to-integer-to-pointer roundtrip via `transmute` is *not* a
   lossless process. If you want to round-trip a pointer through an integer in a way that you
   can get back the original pointer, you need to use `as` casts, or replace the integer type
   by `MaybeUninit&lt;$int&gt;` (and never call `assume_init()`). If you are looking for a way to
   store data of arbitrary type, also use `MaybeUninit&lt;T&gt;` (that will also handle uninitialized
   memory due to padding). If you specifically need to store something that is &quot;either an
   integer or a pointer&quot;, use `*mut ()`: integers can be converted to pointers and back without
   any loss (via `as` casts or via `transmute`).

   # Examples

   There are a few things that `transmute` is really useful for.

   Turning a pointer into a function pointer. This is *not* portable to
   machines where function pointers and data pointers have different sizes.

   ```
   fn foo() -&gt; i32 {
       0
   }
   // Crucially, we `as`-cast to a raw pointer before `transmute`ing to a function pointer.
   // This avoids an integer-to-pointer `transmute`, which can be problematic.
   // Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.
   let pointer = foo as *const ();
   let function = unsafe {
       std::mem::transmute::&lt;*const (), fn() -&gt; i32&gt;(pointer)
   };
   assert_eq!(function(), 0);
   ```

   Extending a lifetime, or shortening an invariant lifetime. This is
   advanced, very unsafe Rust!

   ```
   struct R&lt;'a&gt;(&amp;'a i32);
   unsafe fn extend_lifetime&lt;'b&gt;(r: R&lt;'b&gt;) -&gt; R&lt;'static&gt; {
       unsafe { std::mem::transmute::&lt;R&lt;'b&gt;, R&lt;'static&gt;&gt;(r) }
   }

   unsafe fn shorten_invariant_lifetime&lt;'b, 'c&gt;(r: &amp;'b mut R&lt;'static&gt;)
                                                -&gt; &amp;'b mut R&lt;'c&gt; {
       unsafe { std::mem::transmute::&lt;&amp;'b mut R&lt;'static&gt;, &amp;'b mut R&lt;'c&gt;&gt;(r) }
   }
   ```

   # Alternatives

   Don't despair: many uses of `transmute` can be achieved through other means.
   Below are common applications of `transmute` which can be replaced with safer
   constructs.

   Turning raw bytes (`[u8; SZ]`) into `u32`, `f64`, etc.:

   ```
   # #![allow(unnecessary_transmutes)]
   let raw_bytes = [0x78, 0x56, 0x34, 0x12];

   let num = unsafe {
       std::mem::transmute::&lt;[u8; 4], u32&gt;(raw_bytes)
   };

   // use `u32::from_ne_bytes` instead
   let num = u32::from_ne_bytes(raw_bytes);
   // or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness
   let num = u32::from_le_bytes(raw_bytes);
   assert_eq!(num, 0x12345678);
   let num = u32::from_be_bytes(raw_bytes);
   assert_eq!(num, 0x78563412);
   ```

   Turning a pointer into a `usize`:

   ```no_run
   let ptr = &amp;0;
   let ptr_num_transmute = unsafe {
       std::mem::transmute::&lt;&amp;i32, usize&gt;(ptr)
   };

   // Use an `as` cast instead
   let ptr_num_cast = ptr as *const i32 as usize;
   ```

   Note that using `transmute` to turn a pointer to a `usize` is (as noted above) [undefined
   behavior][ub] in `const` contexts. Also outside of consts, this operation might not behave
   as expected -- this is touching on many unspecified aspects of the Rust memory model.
   Depending on what the code is doing, the following alternatives are preferable to
   pointer-to-integer transmutation:
   - If the code just wants to store data of arbitrary type in some buffer and needs to pick a
     type for that buffer, it can use [`MaybeUninit`][crate::mem::MaybeUninit].
   - If the code actually wants to work on the address the pointer points to, it can use `as`
     casts or [`ptr.addr()`][pointer::addr].

   Turning a `*mut T` into a `&amp;mut T`:

   ```
   let ptr: *mut i32 = &amp;mut 0;
   let ref_transmuted = unsafe {
       std::mem::transmute::&lt;*mut i32, &amp;mut i32&gt;(ptr)
   };

   // Use a reborrow instead
   let ref_casted = unsafe { &amp;mut *ptr };
   ```

   Turning a `&amp;mut T` into a `&amp;mut U`:

   ```
   let ptr = &amp;mut 0;
   let val_transmuted = unsafe {
       std::mem::transmute::&lt;&amp;mut i32, &amp;mut u32&gt;(ptr)
   };

   // Now, put together `as` and reborrowing - note the chaining of `as`
   // `as` is not transitive
   let val_casts = unsafe { &amp;mut *(ptr as *mut i32 as *mut u32) };
   ```

   Turning a `&amp;str` into a `&amp;[u8]`:

   ```
   // this is not a good way to do this.
   let slice = unsafe { std::mem::transmute::&lt;&amp;str, &amp;[u8]&gt;(&quot;Rust&quot;) };
   assert_eq!(slice, &amp;[82, 117, 115, 116]);

   // You could use `str::as_bytes`
   let slice = &quot;Rust&quot;.as_bytes();
   assert_eq!(slice, &amp;[82, 117, 115, 116]);

   // Or, just use a byte string, if you have control over the string
   // literal
   assert_eq!(b&quot;Rust&quot;, &amp;[82, 117, 115, 116]);
   ```

   Turning a `Vec&lt;&amp;T&gt;` into a `Vec&lt;Option&lt;&amp;T&gt;&gt;`.

   To transmute the inner type of the contents of a container, you must make sure to not
   violate any of the container's invariants. For `Vec`, this means that both the size
   *and alignment* of the inner types have to match. Other containers might rely on the
   size of the type, alignment, or even the `TypeId`, in which case transmuting wouldn't
   be possible at all without violating the container invariants.

   ```
   let store = [0, 1, 2, 3];
   let v_orig = store.iter().collect::&lt;Vec&lt;&amp;i32&gt;&gt;();

   // clone the vector as we will reuse them later
   let v_clone = v_orig.clone();

   // Using transmute: this relies on the unspecified data layout of `Vec`, which is a
   // bad idea and could cause Undefined Behavior.
   // However, it is no-copy.
   let v_transmuted = unsafe {
       std::mem::transmute::&lt;Vec&lt;&amp;i32&gt;, Vec&lt;Option&lt;&amp;i32&gt;&gt;&gt;(v_clone)
   };

   let v_clone = v_orig.clone();

   // This is the suggested, safe way.
   // It may copy the entire vector into a new one though, but also may not.
   let v_collected = v_clone.into_iter()
                            .map(Some)
                            .collect::&lt;Vec&lt;Option&lt;&amp;i32&gt;&gt;&gt;();

   let v_clone = v_orig.clone();

   // This is the proper no-copy, unsafe way of &quot;transmuting&quot; a `Vec`, without relying on the
   // data layout. Instead of literally calling `transmute`, we perform a pointer cast, but
   // in terms of converting the original inner type (`&amp;i32`) to the new one (`Option&lt;&amp;i32&gt;`),
   // this has all the same caveats. Besides the information provided above, also consult the
   // [`from_raw_parts`] documentation.
   let v_from_raw = unsafe {
       // Ensure the original vector is not dropped.
       let mut v_clone = std::mem::ManuallyDrop::new(v_clone);
       Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option&lt;&amp;i32&gt;,
                           v_clone.len(),
                           v_clone.capacity())
   };
   ```

   [`from_raw_parts`]: ../../std/vec/struct.Vec.html#method.from_raw_parts

   Implementing `split_at_mut`:

   ```
   use std::{slice, mem};

   // There are multiple ways to do this, and there are multiple problems
   // with the following (transmute) way.
   fn split_at_mut_transmute&lt;T&gt;(slice: &amp;mut [T], mid: usize)
                                -&gt; (&amp;mut [T], &amp;mut [T]) {
       let len = slice.len();
       assert!(mid &lt;= len);
       unsafe {
           let slice2 = mem::transmute::&lt;&amp;mut [T], &amp;mut [T]&gt;(slice);
           // first: transmute is not type safe; all it checks is that T and
           // U are of the same size. Second, right here, you have two
           // mutable references pointing to the same memory.
           (&amp;mut slice[0..mid], &amp;mut slice2[mid..len])
       }
   }

   // This gets rid of the type safety problems; `&amp;mut *` will *only* give
   // you a `&amp;mut T` from a `&amp;mut T` or `*mut T`.
   fn split_at_mut_casts&lt;T&gt;(slice: &amp;mut [T], mid: usize)
                            -&gt; (&amp;mut [T], &amp;mut [T]) {
       let len = slice.len();
       assert!(mid &lt;= len);
       unsafe {
           let slice2 = &amp;mut *(slice as *mut [T]);
           // however, you still have two mutable references pointing to
           // the same memory.
           (&amp;mut slice[0..mid], &amp;mut slice2[mid..len])
       }
   }

   // This is how the standard library does it. This is the best method, if
   // you need to do something like this
   fn split_at_stdlib&lt;T&gt;(slice: &amp;mut [T], mid: usize)
                         -&gt; (&amp;mut [T], &amp;mut [T]) {
       let len = slice.len();
       assert!(mid &lt;= len);
       unsafe {
           let ptr = slice.as_mut_ptr();
           // This now has three mutable references pointing at the same
           // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.
           // `slice` is never used after `let ptr = ...`, and so one can
           // treat it as &quot;dead&quot;, and therefore, you only have two real
           // mutable slices.
           (slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid))
       }
   }
   ```</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-transmute_unchecked"><a href="#val-transmute_unchecked" class="anchor"></a><code><span><span class="keyword">val</span> transmute_unchecked : 
  <span><span class="label">t_src</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Like [`transmute`], but even less checked at compile-time: rather than
   giving an error for `size_of::&lt;Src&gt;() != size_of::&lt;Dst&gt;()`, it's
   **Undefined Behavior** at runtime.

   Prefer normal `transmute` where possible, for the extra checking, since
   both do exactly the same thing at runtime, if they both compile.

   This is not expected to ever be exposed directly to users, rather it
   may eventually be exposed through some more-constrained API.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncf128"><a href="#val-truncf128" class="anchor"></a><code><span><span class="keyword">val</span> truncf128 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the integer part of an `f128`.

   The stabilized version of this intrinsic is
   [`f128::trunc`](../../std/primitive.f128.html#method.trunc)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncf16"><a href="#val-truncf16" class="anchor"></a><code><span><span class="keyword">val</span> truncf16 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the integer part of an `f16`.

   The stabilized version of this intrinsic is
   [`f16::trunc`](../../std/primitive.f16.html#method.trunc)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncf32"><a href="#val-truncf32" class="anchor"></a><code><span><span class="keyword">val</span> truncf32 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the integer part of an `f32`.

   The stabilized version of this intrinsic is
   [`f32::trunc`](../../std/primitive.f32.html#method.trunc)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncf64"><a href="#val-truncf64" class="anchor"></a><code><span><span class="keyword">val</span> truncf64 : <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the integer part of an `f64`.

   The stabilized version of this intrinsic is
   [`f64::trunc`](../../std/primitive.f64.html#method.trunc)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_id"><a href="#val-type_id" class="anchor"></a><code><span><span class="keyword">val</span> type_id : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Gets an identifier which is globally unique to the specified type. This
   function will return the same value for a type regardless of whichever
   crate it is invoked in.

   Note that, unlike most intrinsics, this can only be called at compile-time
   as backends do not have an implementation for it. The only caller (its
   stable counterpart) wraps this intrinsic call in a `const` block so that
   backends only see an evaluated constant.

   The stabilized version of this intrinsic is [`core::any::TypeId::of`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_name"><a href="#val-type_name" class="anchor"></a><code><span><span class="keyword">val</span> type_name : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Gets a static string slice containing the name of a type.

   Note that, unlike most intrinsics, this can only be called at compile-time
   as backends do not have an implementation for it. The only caller (its
   stable counterpart) wraps this intrinsic call in a `const` block so that
   backends only see an evaluated constant.

   The stabilized version of this intrinsic is [`core::any::type_name`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typed_swap_nonoverlapping"><a href="#val-typed_swap_nonoverlapping" class="anchor"></a><code><span><span class="keyword">val</span> typed_swap_nonoverlapping : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Non-overlapping *typed* swap of a single value.

   The codegen backends will replace this with a better implementation when
   `T` is a simple type that can be loaded and stored as an immediate.

   The stabilized form of this intrinsic is [`crate::mem::swap`].

   # Safety
   Behavior is undefined if any of the following conditions are violated:

   * Both `x` and `y` must be [valid] for both reads and writes.

   * Both `x` and `y` must be properly aligned.

   * The region of memory beginning at `x` must *not* overlap with the region of memory
     beginning at `y`.

   * The memory pointed by `x` and `y` must both contain values of type `T`.

   [valid]: crate::ptr#safety</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ub_checks"><a href="#val-ub_checks" class="anchor"></a><code><span><span class="keyword">val</span> ub_checks : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns whether we should perform some UB-checking at runtime. This eventually evaluates to
   `cfg!(ub_checks)`, but behaves different from `cfg!` when mixing crates built with different
   flags: if the crate has UB checks enabled or carries the `#[rustc_preserve_ub_checks]`
   attribute, evaluation is delayed until monomorphization (or until the call gets inlined into
   a crate that does not delay evaluation further); otherwise it can happen any time.

   The common case here is a user program built with ub_checks linked against the distributed
   sysroot which is built without ub_checks but with `#[rustc_preserve_ub_checks]`.
   For code that gets monomorphized in the user crate (i.e., generic functions and functions with
   `#[inline]`), gating assertions on `ub_checks()` rather than `cfg!(ub_checks)` means that
   assertions are enabled whenever the *user crate* has UB checks enabled. However, if the
   user has UB checks disabled, the checks will still get optimized out. This intrinsic is
   primarily used by [`crate::ub_checks::assert_unsafe_precondition`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unaligned_volatile_load"><a href="#val-unaligned_volatile_load" class="anchor"></a><code><span><span class="keyword">val</span> unaligned_volatile_load : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs a volatile load from the `src` pointer
   The pointer is not required to be aligned.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unaligned_volatile_store"><a href="#val-unaligned_volatile_store" class="anchor"></a><code><span><span class="keyword">val</span> unaligned_volatile_store : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs a volatile store to the `dst` pointer.
   The pointer is not required to be aligned.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_add"><a href="#val-unchecked_add" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_add : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the result of an unchecked addition, resulting in
   undefined behavior when `x + y &gt; T::MAX` or `x + y &lt; T::MIN`.

   The stable counterpart of this intrinsic is `unchecked_add` on the various
   integer types, such as [`u16::unchecked_add`] and [`i64::unchecked_add`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_div"><a href="#val-unchecked_div" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_div : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs an unchecked division, resulting in undefined behavior
   where `y == 0` or `x == T::MIN &amp;&amp; y == -1`

   Safe wrappers for this intrinsic are available on the integer
   primitives via the `checked_div` method. For example,
   [`u32::checked_div`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_mul"><a href="#val-unchecked_mul" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_mul : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the result of an unchecked multiplication, resulting in
   undefined behavior when `x * y &gt; T::MAX` or `x * y &lt; T::MIN`.

   The stable counterpart of this intrinsic is `unchecked_mul` on the various
   integer types, such as [`u16::unchecked_mul`] and [`i64::unchecked_mul`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_rem"><a href="#val-unchecked_rem" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_rem : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the remainder of an unchecked division, resulting in
   undefined behavior when `y == 0` or `x == T::MIN &amp;&amp; y == -1`

   Safe wrappers for this intrinsic are available on the integer
   primitives via the `checked_rem` method. For example,
   [`u32::checked_rem`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_shl"><a href="#val-unchecked_shl" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_shl : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">u</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs an unchecked left shift, resulting in undefined behavior when
   `y &lt; 0` or `y &gt;= N`, where N is the width of T in bits.

   Safe wrappers for this intrinsic are available on the integer
   primitives via the `checked_shl` method. For example,
   [`u32::checked_shl`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_shr"><a href="#val-unchecked_shr" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_shr : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">u</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs an unchecked right shift, resulting in undefined behavior when
   `y &lt; 0` or `y &gt;= N`, where N is the width of T in bits.

   Safe wrappers for this intrinsic are available on the integer
   primitives via the `checked_shr` method. For example,
   [`u32::checked_shr`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unchecked_sub"><a href="#val-unchecked_sub" class="anchor"></a><code><span><span class="keyword">val</span> unchecked_sub : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the result of an unchecked subtraction, resulting in
   undefined behavior when `x - y &gt; T::MAX` or `x - y &lt; T::MIN`.

   The stable counterpart of this intrinsic is `unchecked_sub` on the various
   integer types, such as [`u16::unchecked_sub`] and [`i64::unchecked_sub`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unlikely"><a href="#val-unlikely" class="anchor"></a><code><span><span class="keyword">val</span> unlikely : <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Hints to the compiler that branch condition is likely to be false.
   Returns the value passed to it.

   Any use other than with `if` statements will probably not have an effect.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unreachable"><a href="#val-unreachable" class="anchor"></a><code><span><span class="keyword">val</span> unreachable : <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Informs the optimizer that this point in the code is not reachable,
   enabling further optimizations.

   N.B., this is very different from the `unreachable!()` macro: Unlike the
   macro, which panics when it is executed, it is *undefined behavior* to
   reach code marked with this function.

   The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-va_arg"><a href="#val-va_arg" class="anchor"></a><code><span><span class="keyword">val</span> va_arg : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ap</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Loads an argument of type `T` from the `va_list` `ap` and increment the
   argument `ap` points to.

   FIXME: document safety requirements</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-va_copy"><a href="#val-va_copy" class="anchor"></a><code><span><span class="keyword">val</span> va_copy : <span><span class="label">dest</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Copies the current location of arglist `src` to the arglist `dst`.

   FIXME: document safety requirements</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-va_end"><a href="#val-va_end" class="anchor"></a><code><span><span class="keyword">val</span> va_end : <span><span class="label">ap</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Destroy the arglist `ap` after initialization with `va_start` or `va_copy`.

   FIXME: document safety requirements</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-variant_count"><a href="#val-variant_count" class="anchor"></a><code><span><span class="keyword">val</span> variant_count : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns the number of variants of the type `T` cast to a `usize`;
   if `T` has no variants, returns `0`. Uninhabited variants will be counted.

   Note that, unlike most intrinsics, this can only be called at compile-time
   as backends do not have an implementation for it. The only caller (its
   stable counterpart) wraps this intrinsic call in a `const` block so that
   backends only see an evaluated constant.

   The to-be-stabilized version of this intrinsic is [`crate::mem::variant_count`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_copy_memory"><a href="#val-volatile_copy_memory" class="anchor"></a><code><span><span class="keyword">val</span> volatile_copy_memory : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with
   a size of `count * size_of::&lt;T&gt;()` and an alignment of `align_of::&lt;T&gt;()`.

   The volatile parameter is set to `true`, so it will not be optimized out
   unless size is equal to zero.

   This intrinsic does not have a stable counterpart.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_copy_nonoverlapping_memory"><a href="#val-volatile_copy_nonoverlapping_memory" class="anchor"></a><code><span><span class="keyword">val</span> volatile_copy_nonoverlapping_memory : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with
   a size of `count` * `size_of::&lt;T&gt;()` and an alignment of `align_of::&lt;T&gt;()`.

   This intrinsic does not have a stable counterpart.
   # Safety

   The safety requirements are consistent with [`copy_nonoverlapping`]
   while the read and write behaviors are volatile,
   which means it will not be optimized out unless `_count` or `size_of::&lt;T&gt;()` is equal to zero.

   [`copy_nonoverlapping`]: ptr::copy_nonoverlapping</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_load"><a href="#val-volatile_load" class="anchor"></a><code><span><span class="keyword">val</span> volatile_load : <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs a volatile load from the `src` pointer.

   The stabilized version of this intrinsic is [`core::ptr::read_volatile`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_set_memory"><a href="#val-volatile_set_memory" class="anchor"></a><code><span><span class="keyword">val</span> volatile_set_memory : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a
   size of `count * size_of::&lt;T&gt;()` and an alignment of `align_of::&lt;T&gt;()`.

   This intrinsic does not have a stable counterpart.
   # Safety

   The safety requirements are consistent with [`write_bytes`] while the write behavior is volatile,
   which means it will not be optimized out unless `_count` or `size_of::&lt;T&gt;()` is equal to zero.

   [`write_bytes`]: ptr::write_bytes</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-volatile_store"><a href="#val-volatile_store" class="anchor"></a><code><span><span class="keyword">val</span> volatile_store : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Performs a volatile store to the `dst` pointer.

   The stabilized version of this intrinsic is [`core::ptr::write_volatile`].</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vtable_align"><a href="#val-vtable_align" class="anchor"></a><code><span><span class="keyword">val</span> vtable_align : <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The intrinsic will return the alignment stored in that vtable.

   # Safety

   `ptr` must point to a vtable.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vtable_size"><a href="#val-vtable_size" class="anchor"></a><code><span><span class="keyword">val</span> vtable_size : <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  The intrinsic will return the size stored in that vtable.

   # Safety

   `ptr` must point to a vtable.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrapping_add"><a href="#val-wrapping_add" class="anchor"></a><code><span><span class="keyword">val</span> wrapping_add : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns (a + b) mod 2&lt;sup&gt;N&lt;/sup&gt;, where N is the width of T in bits.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `wrapping_add` method. For example,
   [`u32::wrapping_add`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrapping_mul"><a href="#val-wrapping_mul" class="anchor"></a><code><span><span class="keyword">val</span> wrapping_mul : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns (a * b) mod 2&lt;sup&gt;N&lt;/sup&gt;, where N is the width of T in bits.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `wrapping_mul` method. For example,
   [`u32::wrapping_mul`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrapping_sub"><a href="#val-wrapping_sub" class="anchor"></a><code><span><span class="keyword">val</span> wrapping_sub : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">a</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">b</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  Returns (a - b) mod 2&lt;sup&gt;N&lt;/sup&gt;, where N is the width of T in bits.

   Note that, unlike most intrinsics, this is safe to call;
   it does not require an `unsafe` block.
   Therefore, implementations must not require the user to uphold
   any safety invariants.

   The stabilized versions of this intrinsic are available on the integer
   primitives via the `wrapping_sub` method. For example,
   [`u32::wrapping_sub`]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_bytes"><a href="#val-write_bytes" class="anchor"></a><code><span><span class="keyword">val</span> write_bytes : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">val_</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">count</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  This is an accidentally-stable alias to [`ptr::write_bytes`]; use that instead.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_via_move"><a href="#val-write_via_move" class="anchor"></a><code><span><span class="keyword">val</span> write_via_move : 
  <span><span class="label">t</span>:<span class="xref-unresolved">Charon</span>.Types.ty <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ptr</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">value</span>:<a href="#type-rust_val">rust_val</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><pre class="language-markdown"><code>  This is an implementation detail of [`crate::ptr::write`] and should
   not be used anywhere else.  See its comments for why this exists.

   This intrinsic can *only* be called where the pointer is a local without
   projections (`write_via_move(ptr, x)`, not `write_via_move( *ptr, x)`) so
   that it trivially obeys runtime-MIR rules about derefs in operands.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_fun"><a href="#val-eval_fun" class="anchor"></a><code><span><span class="keyword">val</span> eval_fun : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-fun_exec">fun_exec</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Charon</span>.Types.generic_args <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">args</span>:<span><a href="#type-rust_val">rust_val</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-ret">ret</a></span></code></div></div></div></body></html>
